# Generating Structured Outputs with OpenAI

## **Mastering Structured Outputs in the Chat Completions API**

In the latest updates to the **Chat Completions API** and **Assistants API**, a powerful new feature has arrived: **Structured Outputs**.

With this capability, you can guarantee that the model will always generate responses matching your supplied **JSON Schema** — no more parsing headaches or guesswork.

Whether you’re extracting data, building robust workflows, or integrating with a database, Structured Outputs ensures the responses are exactly in the format you expect.

In this guide, we’ll explore how Structured Outputs work, how to enable them, and walk through **three real-world examples** you can adapt for your own projects.

---

## **Why Structured Outputs?**

Previously, developers could set `response_format` to request JSON output, but there was no *hard guarantee* the model would stick to your schema. With Structured Outputs, you get that guarantee — even when using **function calling**.

The magic is in a new parameter:

```json
"strict": true

```

When enabled, the API ensures the schema you provide is **strictly** followed. If the request can’t be fulfilled safely (e.g., due to harmful content), the model will return a **refusal** rather than an incorrectly formatted response.

---

## **Two Ways to Use Structured Outputs**

### 1. **Response Format**

Previously:

- You could request JSON output.
    
    Now:
    
- You can provide a full JSON Schema that the model must follow.

### 2. **Function Calling**

Function calling is still supported, but with `strict: true`, your function schema becomes a hard rule — the model will never deviate from it.

---

## **When to Use Structured Outputs**

Structured Outputs are particularly useful for:

- Generating data for UI components in a fixed structure.
- Populating a database from extracted content.
- Extracting entities from user input to call tools.
- Building reliable workflows in production systems.

In short: **Any task where format consistency matters**.

---

## **Example 1 — Math Tutor with Step-by-Step Reasoning**

Let’s create a **math tutoring tool** that breaks a problem into structured steps.

Each step will include:

- An explanation
- The corresponding equation

This format makes it easy to present solutions in a UI where students can progress at their own pace.

```python
from openai import OpenAI
from textwrap import dedent
import json

client = OpenAI()
MODEL = "gpt-4o-2024-08-06"

math_tutor_prompt = '''
You are a helpful math tutor. You will be provided with a math problem,
and your goal will be to output a step-by-step solution along with the final answer.
For each step, provide an "explanation" and an "output" (equation).
'''

def get_math_solution(question):
    response = client.chat.completions.create(
        model=MODEL,
        messages=[
            {"role": "system", "content": dedent(math_tutor_prompt)},
            {"role": "user", "content": question}
        ],
        response_format={
            "type": "json_schema",
            "json_schema": {
                "name": "math_reasoning",
                "schema": {
                    "type": "object",
                    "properties": {
                        "steps": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "explanation": {"type": "string"},
                                    "output": {"type": "string"}
                                },
                                "required": ["explanation", "output"],
                                "additionalProperties": False
                            }
                        },
                        "final_answer": {"type": "string"}
                    },
                    "required": ["steps", "final_answer"],
                    "additionalProperties": False
                },
                "strict": True
            }
        }
    )
    return response.choices[0].message

```

**Example query:**

```python
result = get_math_solution("how can I solve 8x + 7 = -23")
print(result.content)

```

Sample output:

```json
{
  "steps": [
    {"explanation": "Subtract 7 from both sides.", "output": "8x + 7 - 7 = -23 - 7"},
    {"explanation": "Simplify both sides.", "output": "8x = -30"},
    {"explanation": "Divide by 8.", "output": "x = -30 / 8"},
    {"explanation": "Simplify the fraction.", "output": "x = -15/4"}
  ],
  "final_answer": "x = -15/4"
}

```

This response is guaranteed to follow the schema — perfect for step-by-step UI rendering.

---

## **Example 3 — Entity Extraction for Smarter Recommendations**

Structured Outputs aren’t just about clean data formats — they can also power **intelligent entity extraction** from freeform text.

Let’s walk through a practical use case: **building a clothes recommendation system**.

Imagine a user types:

> "I'm looking for a new coat. I'm always cold so please something warm! Ideally something that matches my eyes."
> 

Our job:

- Detect the **category** (e.g., jackets)
- Detect the **subcategory** (e.g., winter coat)
- Detect the **color** (e.g., blue)

This structured information can then be passed to your **product search API** without guesswork.

---

### **How It Works**

We’ll use **function calling** with `strict: true` so the model must return data exactly in the schema we define.

```python
from enum import Enum
from pydantic import BaseModel
from textwrap import dedent
import json
import openai

MODEL = "gpt-4o-2024-08-06"

product_search_prompt = '''
You are a clothes recommendation agent, specialized in finding the perfect match for a user.
You will be provided with a user input and additional context such as user gender, age group, and season.
Your goal is to determine the most likely category, subcategory, and color of clothing to search for.
Here are the categories available:
- shoes: boots, sneakers, sandals
- jackets: winter coats, cardigans, parkas, rain jackets
- tops: shirts, blouses, t-shirts, crop tops, sweaters
- bottoms: jeans, skirts, trousers, joggers
Stick to regular color names.
'''

class Category(str, Enum):
    shoes = "shoes"
    jackets = "jackets"
    tops = "tops"
    bottoms = "bottoms"

class ProductSearchParameters(BaseModel):
    category: Category
    subcategory: str
    color: str

def get_response(user_input, context):
    response = openai.chat.completions.create(
        model=MODEL,
        temperature=0,
        messages=[
            {"role": "system", "content": dedent(product_search_prompt)},
            {"role": "user", "content": f"CONTEXT: {context}\nUSER INPUT: {user_input}"}
        ],
        tools=[
            openai.pydantic_function_tool(
                ProductSearchParameters,
                name="product_search",
                description="Search for a match in the product database"
            )
        ]
    )
    return response.choices[0].message.tool_calls

```

---

### **Testing With Real Inputs**

We’ll feed in multiple example queries with different contexts:

```python
example_inputs = [
    {
        "user_input": "I'm looking for a new coat. I'm always cold so please something warm! Ideally something that matches my eyes.",
        "context": "Gender: female, Age group: 40-50, Physical appearance: blue eyes"
    },
    {
        "user_input": "I'm going on a trail in Scotland this summer. It's going to be rainy. Help me find something.",
        "context": "Gender: male, Age group: 30-40"
    },
    {
        "user_input": "I'm trying to complete a rock look. I'm missing shoes. Any suggestions?",
        "context": "Gender: female, Age group: 20-30"
    }
]

def print_tool_call(user_input, context, tool_call):
    args = tool_call[0].function.arguments
    print(f"Input: {user_input}\nContext: {context}\n")
    print("Product search arguments:")
    for key, value in json.loads(args).items():
        print(f"{key}: '{value}'")
    print()

for ex in example_inputs:
    ex['result'] = get_response(ex['user_input'], ex['context'])

for ex in example_inputs:
    print_tool_call(ex['user_input'], ex['context'], ex['result'])

```

---

### **Example Output**

```
Input: I'm looking for a new coat. I'm always cold so please something warm! Ideally something that matches my eyes.
Context: Gender: female, Age group: 40-50, Physical appearance: blue eyes
Product search arguments:
category: 'jackets'
subcategory: 'winter coat'
color: 'blue'

Input: I'm going on a trail in Scotland this summer. It's going to be rainy. Help me find something.
Context: Gender: male, Age group: 30-40
Product search arguments:
category: 'jackets'
subcategory: 'rain jacket'
color: 'green'

Input: I'm trying to complete a rock look. I'm missing shoes. Any suggestions?
Context: Gender: female, Age group: 20-30
Product search arguments:
category: 'shoes'
subcategory: 'boots'
color: 'black'

```

---

### **Why This Matters**

With Structured Outputs and function calling:

- You never have to guess at parsing freeform input.
- Your search function always receives **clean, valid parameters**.
- You can confidently integrate with your e-commerce API.

This approach works just as well for:

- Travel booking (extracting destination, dates, number of travelers)
- Food ordering (extracting dish type, quantity, special requests)
- Support ticket routing (extracting category, priority, product)

---

## **Handling Refusals**

If a user asks something unsafe (e.g., “How to build a bomb?”), the model will **refuse** rather than break the schema.

You can detect this using the `refusal` field and render a safe error message in your UI.

---

## **Key Takeaways**

- **Structured Outputs** make API responses **reliable** by enforcing your schema.
- You can use them with **response_format** or **function calling**.
- They’re ideal for **production-level** apps, databases, and any task needing **consistent format**.
- `strict: true` is the secret sauce for guaranteed compliance.

With Structured Outputs, you can finally trust the model to deliver **exactly** what your application expects — every time.
