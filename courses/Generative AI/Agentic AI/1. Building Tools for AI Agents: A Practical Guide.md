# 1. Building Tools for AI Agents: A Practical Guide

In our previous discussion, we explored the fascinating world of AI agents and how their ability to make independent decisions and take actions sets them apart. A core component enabling this action is **function calling**, which allows agents to interact with external tools and services. But how do you actually *create* one of these powerful tools for your AI agent? This blog will guide you through the process, using the example of an image generation and storage tool, cleaned up for clarity.

---

## Understanding AI Agent Tools

Before diving into the code, let's clarify what a "tool" means in the context of AI agents.

An **AI agent tool** is a dedicated function or module that extends the agent's capabilities beyond its inherent language understanding. It allows the agent to perform specific, external actions. Imagine giving your AI assistant a new gadget or skill – that's what a tool represents. These tools can:

- **Fetch Real-Time Information:** Like current weather, news headlines, or stock prices.
- **Execute Complex Operations:** Such as performing calculations, running simulations, or analyzing data.
- **Interact with External Systems:** Sending emails, updating databases, managing calendars, or, as we'll see, generating and storing images.

The power lies in the agent's autonomy: it intelligently decides *when* and *how* to use these tools to achieve its goals.

---

### Step 1: Generating an Image with DALL·E

The first part of our tool involves using DALL·E, a powerful AI model by OpenAI, to create images from text descriptions.

To interact with DALL·E, we'll use the `openai` Python library, specifically the `AzureOpenAI` client if you're deploying on Azure. You'll need to configure it with your API key, endpoint, and API version.

```python
import os
import requests
import tempfile
import uuid
import json
from openai import AzureOpenAI
from werkzeug.datastructures import FileStorage
# Assuming these are part of your agent framework setup
from agents import function_tool, RunContextWrapper
# Assuming UserInfo and AzureBlobUtilities are custom classes you've defined
# For this example, we'll simplify AzureBlobUtilities and UserInfo for demonstration.

# --- Configuration for DALL·E (replace with your actual environment variables) ---
DALLE_API_VERSION = os.environ.get('AZURE_DALLE_API_VERSION')
DALLE_ENDPOINT = os.environ.get('AZURE_DALLE_ENDPOINT')
DALLE_API_KEY = os.environ.get('AZURE_DALLE_API_KEY')
DALLE_MODEL = os.environ.get('DALLE_MODEL')

# Initialize DALL·E client
dalle_client = AzureOpenAI(
    api_version=DALLE_API_VERSION,
    azure_endpoint=DALLE_ENDPOINT,
    api_key=DALLE_API_KEY
)

# --- Code Snippet: DALL·E Image Generation Logic ---
def generate_dalle_image(prompt: str, size: str = "1024x1024") -> str:
    """
    Generates an image using DALL·E and returns the temporary URL.
    """
    valid_sizes = ["1024x1024", "1792x1024", "1024x1792"]
    if size not in valid_sizes:
        raise ValueError(f"Image size must be one of {valid_sizes}. Got: {size}")

    # Call the DALL·E API to generate the image
    response = dalle_client.images.generate(
        model=DALLE_MODEL,
        prompt=prompt,
        size=size,
        n=1,  # Generate one image
        quality="hd"
    )
    # The API returns a URL to the generated image, which is temporary
    image_url = response.data[0].url
    return image_url
```

- **`AzureOpenAI` Client:** This client facilitates secure communication with your DALL·E deployment on Azure.
- **`generate` Method:** The core of the DALL·E interaction. It takes the `prompt` (your description of the desired image), `size`, and other parameters like `quality`.
- **Temporary URL:** DALL·E returns a URL pointing to the newly generated image. This URL is temporary, meaning we need to download the image to store it permanently.

---

### Step 2: Uploading the Image to Azure Blob Storage

Once we have the image from DALL·E, the next step is to store it permanently so it can be accessed later. Azure Blob Storage is a scalable and secure solution for this.

For demonstration purposes, let's create a simplified `AzureBlobUtilities` class. In a real application, this class would handle authentication and proper container client initialization.

```python
# --- Simplified AzureBlobUtilities for demonstration ---
# In a real application, you'd initialize BlobServiceClient with proper credentials
# and container_name (e.g., from environment variables)
from azure.storage.blob import BlobServiceClient, ContentSettings # pip install azure-storage-blob

class AzureBlobUtilities:
    def __init__(self, connection_string: str, container_name: str):
        self.blob_service_client = BlobServiceClient.from_connection_string(connection_string)
        self.container_client = self.blob_service_client.get_container_client(container_name)
        # Ensure the container exists (optional, but good for setup)
        try:
            self.container_client.create_container()
        except Exception:
            pass # Container likely already exists

    def upload_file(self, file: FileStorage, user_id: str, session_id: str, folder: str) -> str:
        """
        Uploads a file to Azure Blob Storage under user_id/session_id/ in a specified folder.
        Returns the public URL of the uploaded file.
        """
        # Construct the blob path: folder/user_id/session_id/filename
        blob_path = f"{folder}/{user_id}/{session_id}/{file.filename}"
        blob_client = self.container_client.get_blob_client(blob_path)

        # Determine content type based on file extension
        content_type = "application/octet-stream"
        if file.filename.lower().endswith(".pdf"):
            content_type = "application/pdf"
        elif file.filename.lower().endswith((".jpg", ".jpeg")):
            content_type = "image/jpeg"
        elif file.filename.lower().endswith(".png"):
            content_type = "image/png"

        try:
            blob_client.upload_blob(
                file.stream,  # Use file.stream for FileStorage object
                overwrite=True,
                content_settings=ContentSettings(content_type=content_type),
            )
            return blob_client.url
        except Exception as e:
            print(f"Error uploading file {file.filename}: {str(e)}") # Using print instead of logger
            return None

# Example Initialization (replace with your actual values)
AZURE_STORAGE_CONNECTION_STRING = os.environ.get('AZURE_STORAGE_CONNECTION_STRING', 'DefaultEndpointsProtocol=...')
AZURE_BLOB_CONTAINER_NAME = os.environ.get('AZURE_BLOB_CONTAINER_NAME', 'ai-agent-images')
azure_blob_utils = AzureBlobUtilities(AZURE_STORAGE_CONNECTION_STRING, AZURE_BLOB_CONTAINER_NAME)

# --- Code Snippet: Image Download and Upload Logic ---
def download_and_upload_image(openai_image_url: str, user_id: str, session_id: str) -> str:
    """
    Downloads an image from a URL, saves it temporarily, and uploads to Azure Blob.
    Returns the Azure Blob URL.
    """
    # Step 1: Download the image from the temporary OpenAI URL
    download_response = requests.get(openai_image_url)
    if download_response.status_code != 200:
        raise Exception(f"Failed to download image from OpenAI: {download_response.status_code}")

    # Step 2: Save to a temporary file
    # Using a UUID to ensure unique filename
    unique_id = uuid.uuid4().hex
    # Include user and session IDs in the filename for better organization/debugging
    temp_filename = f"generated_image_{user_id}_{session_id}_{unique_id}.png"
    temp_filepath = os.path.join(tempfile.gettempdir(), temp_filename)

    try:
        with open(temp_filepath, "wb") as tmp_file:
            tmp_file.write(download_response.content)

        # Step 3: Upload to Azure Blob Storage
        # The FileStorage wrapper is often used when dealing with file uploads in web frameworks.
        # Here we simulate it by wrapping the temporary file.
        with open(temp_filepath, "rb") as f:
            file_obj = FileStorage(stream=f, filename=temp_filename, content_type="image/png")
            blob_url = azure_blob_utils.upload_file(
                file=file_obj,
                user_id=user_id,
                session_id=session_id,
                folder="ai-generated-content" # A logical folder within your blob container
            )
        return blob_url
    finally:
        # Ensure the temporary file is always deleted
        if os.path.exists(temp_filepath):
            os.unlink(temp_filepath)
```

- **`requests.get()`:** Downloads the image content from the DALL·E-provided URL.
- **`tempfile.gettempdir()` and `os.path.join()`:** Safely creates a path for a temporary file to store the image before uploading.
- **`FileStorage`:** This class from `werkzeug` is often used to represent uploaded files in web contexts. Here, we create an instance to mimic such an object, as `azure_blob_utils.upload_file` expects it.
- **`azure_blob_utils.upload_file()`:** Our custom utility handles the actual upload to Azure Blob Storage, organizing files by user and session ID for easy management.
- **`finally` Block:** Crucially, this ensures that the temporary file created on the local system is deleted, preventing disk clutter.

---

```python
import os
import requests
import tempfile
import uuid
import json
from openai import AzureOpenAI
from werkzeug.datastructures import FileStorage

# Assuming these are part of your agent framework setup
from agents import function_tool, RunContextWrapper

# --- Configuration for DALL·E (replace with your actual environment variables) ---
DALLE_API_VERSION = os.environ.get('AZURE_DALLE_API_VERSION', '2024-02-15-preview')
DALLE_ENDPOINT = os.environ.get('AZURE_DALLE_ENDPOINT', 'YOUR_DALLE_ENDPOINT')
DALLE_API_KEY = os.environ.get('AZURE_DALLE_API_KEY', 'YOUR_DALLE_API_KEY')
DALLE_MODEL = os.environ.get('DALLE_MODEL', 'dall-e-3')

# --- Simplified AzureBlobUtilities for demonstration ---
# In a real application, you'd initialize BlobServiceClient with proper credentials
# and container_name (e.g., from environment variables)
from azure.storage.blob import BlobServiceClient, ContentSettings # pip install azure-storage-blob

class AzureBlobUtilities:
    def __init__(self, connection_string: str, container_name: str):
        self.blob_service_client = BlobServiceClient.from_connection_string(connection_string)
        self.container_client = self.blob_service_client.get_container_client(container_name)
        # Ensure the container exists (optional, but good for setup)
        try:
            self.container_client.create_container()
        except Exception:
            pass # Container likely already exists

    def upload_file(self, file: FileStorage, user_id: str, session_id: str, folder: str) -> str:
        """
        Uploads a file to Azure Blob Storage under user_id/session_id/ in a specified folder.
        Returns the public URL of the uploaded file.
        """
        # Construct the blob path: folder/user_id/session_id/filename
        blob_path = f"{folder}/{user_id}/{session_id}/{file.filename}"
        blob_client = self.container_client.get_blob_client(blob_path)

        # Determine content type based on file extension
        content_type = "application/octet-stream"
        if file.filename.lower().endswith(".pdf"):
            content_type = "application/pdf"
        elif file.filename.lower().endswith((".jpg", ".jpeg")):
            content_type = "image/jpeg"
        elif file.filename.lower().endswith(".png"):
            content_type = "image/png"

        try:
            blob_client.upload_blob(
                file.stream,  # Use file.stream for FileStorage object
                overwrite=True,
                content_settings=ContentSettings(content_type=content_type),
            )
            return blob_client.url
        except Exception as e:
            print(f"Error uploading file {file.filename}: {str(e)}")
            return None

# Initialize DALL·E client and Azure Blob utility
dalle_client = AzureOpenAI(
    api_version=DALLE_API_VERSION,
    azure_endpoint=DALLE_ENDPOINT,
    api_key=DALLE_API_KEY
)

AZURE_STORAGE_CONNECTION_STRING = os.environ.get('AZURE_STORAGE_CONNECTION_STRING', 'DefaultEndpointsProtocol=...')
AZURE_BLOB_CONTAINER_NAME = os.environ.get('AZURE_BLOB_CONTAINER_NAME', 'ai-agent-images')
azure_blob_utils = AzureBlobUtilities(AZURE_STORAGE_CONNECTION_STRING, AZURE_BLOB_CONTAINER_NAME)

# Placeholder for UserInfo, assuming it's a dataclass or similar
class UserInfo:
    def __init__(self, user_id: str, session_id: str):
        self.user_id = user_id
        self.session_id = session_id

@function_tool
def generate_image(wrapper: RunContextWrapper[UserInfo], prompt: str, style: str = "realistic", size: str = "1024x1024") -> str:
    """Generate an image using DALL·E, save to Azure Blob Storage, and return a JSON string with the blob URL.

    This tool takes a text description (prompt) and generates an image, then stores it.

    Args:
        wrapper (RunContextWrapper[UserInfo]): Provides context about the current user and session.
                                               Used for organizing stored files.
        prompt (str): The detailed text description of the image to generate.
        style (str, optional): The artistic style for the image (e.g., "realistic", "cartoon", "abstract").
                               Defaults to "realistic".
        size (str, optional): The dimensions of the image (e.g., "1024x1024", "1792x1024", "1024x1792").
                              Defaults to "1024x1024".

    Returns:
        str: A JSON string containing details of the generated image, including:
             - "tool_type": Identifier for the tool type ("image_generator").
             - "agent_responsible": The name of the agent calling this tool (e.g., "Image Creation Agent").
             - "original_question": The initial question or intent that led to this tool call.
             - "image_url": The public URL where the generated image is stored in Azure Blob Storage.
             - "size": The size of the generated image.
             - "style": The style of the generated image.
    """
    print(f"Generating image with prompt: {prompt}, style: {style}, size: {size}")

    valid_sizes = ["1024x1024", "1792x1024", "1024x1792"]
    if size not in valid_sizes:
        raise ValueError(f"Size must be one of {valid_sizes}. Got: {size}")

    # Step 1: Generate image from OpenAI (DALL·E)
    response = dalle_client.images.generate(
        model=DALLE_MODEL,
        prompt=prompt,
        size=size,
        n=1,
        quality="hd"
    )
    openai_image_url = response.data[0].url
    print(f"Image generated. OpenAI URL: {openai_image_url}")

    # Step 2: Download the image
    download_response = requests.get(openai_image_url)
    if download_response.status_code != 200:
        raise Exception(f"Failed to download image from OpenAI: {download_response.status_code}")

    # Step 3: Save to a temporary file
    unique_id = uuid.uuid4().hex
    # Use user_id and session_id from the context for organizing files in blob storage
    image_filename = f"generated_image_{wrapper.context.user_id}_{wrapper.context.session_id}_{unique_id}.png"
    temp_filepath = os.path.join(tempfile.gettempdir(), image_filename)

    try:
        with open(temp_filepath, "wb") as tmp_file:
            tmp_file.write(download_response.content)

        # Step 4: Upload to blob
        with open(temp_filepath, "rb") as f:
            file_obj = FileStorage(stream=f, filename=image_filename, content_type="image/png")
            blob_url = azure_blob_utils.upload_file(
                file=file_obj,
                user_id=wrapper.context.user_id,
                session_id=wrapper.context.session_id,
                folder="etexchat" # A logical folder within your blob container
            )
        print(f"Image uploaded to blob: {blob_url}")
    finally:
        os.unlink(temp_filepath) # Always clean up the temporary file

    # Step 5: Return structured result with blob URL and other important info
    return json.dumps({
        "tool_type": "image_generator",
        "agent_responsible": "Etex Mate Image Generator Agent", # Example agent name
        "original_question": prompt, # The original prompt serves as the original question
        "image_url": blob_url,
        "size": size,
        "style": style
    })
```