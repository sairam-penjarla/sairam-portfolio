# Building Multiple Agents: Specialization Through Agent Teams

We've built agents that can converse, remember, and use tools. But as tasks become more complex, a single generalist agent starts to show limitations. Just as organizations have specialistsâ€”engineers, designers, analystsâ€”our agent systems can benefit from specialization too.

Today, we're building **multiple agents**â€”creating teams of specialized agents where each has unique expertise, personality, and capabilities. By the end, you'll understand how to architect multi-agent systems where agents collaborate to handle diverse user needs.

## The Case for Multiple Agents

### Why Not Just One Smart Agent?

You might wonder: "Why not make one really capable agent that can do everything?" Here's why specialization matters:

**1. Focused Expertise**

- A medical agent trained on medical knowledge
- A coding agent optimized for programming tasks
- A customer service agent tuned for empathy and helpfulness

**2. Distinct Personalities**

- Formal legal agent vs. casual creative agent
- Different tones for different contexts
- Tailored communication styles

**3. Separate Tool Access**

- Medical agent has healthcare databases
- Finance agent has market data APIs
- Each agent only sees relevant tools

**4. Clearer Boundaries**

- Legal agent doesn't give medical advice
- Financial agent doesn't write code
- Reduced risk of cross-domain errors

**5. Easier Maintenance**

- Update medical agent without affecting others
- Test changes in isolation
- Clear responsibility for each domain

**6. Performance Optimization**

- Some agents can use smaller, faster models
- Critical agents get premium models
- Resource allocation matches importance

## Setting Up the Foundation

Let's start with our familiar setup:

```python
import os
from dotenv import load_dotenv
from openai import AsyncAzureOpenAI
from agents import Agent, OpenAIChatCompletionsModel, function_tool, Runner

load_dotenv()

agent_client = AsyncAzureOpenAI(
    api_key=os.getenv("GPT_4_1_AZURE_OPENAI_API_KEY"),
    api_version=os.getenv("GPT_4_1_AZURE_OPENAI_API_VERSION"),
    azure_endpoint=os.getenv("GPT_4_1_AZURE_OPENAI_API_ENDPOINT"),
    azure_deployment=os.getenv("GPT_4_1_AZURE_OPENAI_API_MODEL_NAME"),
)
model_name = os.getenv("GPT_4_1_AZURE_OPENAI_API_MODEL_NAME")

```

Nothing new hereâ€”we're establishing our connection to the language model. All our agents will share this client, but each will have distinct instructions and capabilities.

## Creating Specialized Agents

Let's create two agents with very different personalities:

### Agent 1: The Chef

```python
chef_agent = Agent(
    name="Chef Agent",
    instructions="You are a Chef who can provide recipes. But you always talk in UPPER CASE. NO EXCEPTIONS.",
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
)

```

### Agent 2: The Doctor

```python
doctor_agent = Agent(
    name="Doctor Agent",
    instructions="You are a Doctor who can provide medical advice. But your responses should be filled with emojis everywhere. NO EXCEPTIONS.",
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
)

```

### What Makes Them Different?

Both agents use the same underlying model, but they're completely different entities:

**Chef Agent:**

- **Domain**: Culinary expertise
- **Personality**: Enthusiastic, speaks in CAPS
- **Specialty**: Recipes, cooking techniques, ingredients

**Doctor Agent:**

- **Domain**: Medical advice
- **Personality**: Friendly, emoji-heavy communication
- **Specialty**: Health symptoms, basic medical guidance

The instructions define their entire identity. These aren't just different promptsâ€”they're different agents with different capabilities and boundaries.

### Why These Specific Instructions?

The exaggerated personalities (CAPS for chef, emojis for doctor) serve a pedagogical purposeâ€”they make it visually obvious which agent is responding. In production, you'd use more subtle differentiation:

**Production Chef Agent:**

```python
instructions="""
You are a professional chef with expertise in international cuisine.
Provide detailed recipes with measurements, cooking times, and techniques.
Focus on clarity and precision. Always include prep time and difficulty level.
"""

```

**Production Doctor Agent:**

```python
instructions="""
You are a medical information assistant. Provide evidence-based health information.
Always emphasize that you're not a replacement for professional medical advice.
Be empathetic and clear. Include when to seek immediate medical attention.
"""

```

But for learning, the dramatic differences help us understand agent switching clearly.

## Creating the Main Orchestrator Agent

Now we need a "front desk" agent that routes requests to specialists:

```python
from agents import handoff

main_agent = Agent(
    name="Main Agent",
    instructions="You are an AI agent",
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
    handoffs=[
        handoff(chef_agent),
        handoff(doctor_agent),
    ]
)

```

### Understanding Handoffs

The `handoffs` parameter is where multi-agent magic happens:

```python
handoffs=[
    handoff(chef_agent),
    handoff(doctor_agent),
]

```

**What is a Handoff?**

A handoff is a mechanism that allows one agent to transfer control to another agent. When you register handoffs, you're telling the main agent:

"Hey, if you encounter a query you can't handle or that's better suited for a specialist, you can transfer control to one of these agents."

The `handoff()` function wraps an agent in a way that makes it available as a transfer target. Under the hood, it creates a "tool" that represents transferring to that agent.

**How Does the Main Agent Choose?**

The main agent examines:

1. **Available handoffs**: "I can transfer to Chef Agent or Doctor Agent"
2. **Agent names and instructions**: Each specialized agent's identity
3. **User query**: "What does the user need?"
4. **Reasoning**: "This is about recipes â†’ Chef Agent is appropriate"

The main agent autonomously decides when and to whom to hand off.

### The Main Agent's Role

```python
instructions="You are an AI agent"

```

Notice how minimal the main agent's instructions are. That's intentional! The main agent is a **router**, not a specialist. Its job is to:

- Greet users
- Understand their needs
- Decide which specialist can help
- Hand off to the appropriate agent
- (Later) Coordinate between multiple specialists if needed

Think of it as a receptionist who directs you to the right department.

## Building the Conversational Interface

Let's create our familiar conversation wrapper with memory:

```python
messages = []

async def ask_agent(query: str):
    global messages
    input_msg = [{"role": "user", "content": query}]
    result = await Runner.run(main_agent, input=messages + input_msg)
    messages = result.to_input_list()
    display(Markdown(result.final_output))

```

This is the same memory pattern we learned earlierâ€”maintaining conversation history across interactions. But now, the history includes handoffs between agents.

## Seeing Multi-Agent Collaboration in Action

### Interaction 1: Initial Greeting

```python
await ask_agent("Hi. How can you help me")

```

**Expected Response:**

```
Hello! I'm here to assist you. I can help you with:

- Cooking and recipes (I can connect you with our Chef Agent)
- Health and medical questions (I can connect you with our Doctor Agent)

What would you like help with today?

```

**What Happened:**

- Main agent responded directly
- No handoff neededâ€”the query was about agent capabilities
- Main agent can handle this generalist query itself

### Interaction 2: Recipe Request

```python
await ask_agent("What's a good recipe for pasta?")

```

**Expected Response:**

```
HERE'S A FANTASTIC PASTA RECIPE FOR YOU!

CLASSIC SPAGHETTI AGLIO E OLIO

INGREDIENTS:
- 400G SPAGHETTI
- 6 CLOVES GARLIC, THINLY SLICED
- 1/2 CUP EXTRA VIRGIN OLIVE OIL
- 1 TSP RED PEPPER FLAKES
- FRESH PARSLEY, CHOPPED
- PARMESAN CHEESE (OPTIONAL)
- SALT TO TASTE

INSTRUCTIONS:
1. BOIL SALTED WATER AND COOK SPAGHETTI AL DENTE
2. WHILE PASTA COOKS, HEAT OLIVE OIL IN A LARGE PAN
3. ADD SLICED GARLIC AND RED PEPPER FLAKES
4. SAUTÃ‰ UNTIL GARLIC IS GOLDEN (DON'T BURN IT!)
5. DRAIN PASTA, RESERVE 1 CUP PASTA WATER
6. ADD PASTA TO THE PAN WITH GARLIC OIL
7. TOSS WELL, ADDING PASTA WATER IF NEEDED
8. FINISH WITH FRESH PARSLEY AND PARMESAN

COOK TIME: 15 MINUTES
SERVES: 4 PEOPLE

BUON APPETITO!

```

**What Happened:**

1. Main agent received: "What's a good recipe for pasta?"
2. Main agent reasoned: "This is about cooking/recipes"
3. Main agent checked handoffs: "I have a Chef Agent for this"
4. Main agent handed off to chef_agent
5. Chef agent responded in its distinctive style (ALL CAPS)
6. Response came back through the main agent to the user

### Interaction 3: Medical Query

```python
await ask_agent("I am feeling headache and feverish. What should I do?")

```

**Expected Response:**

```
Oh no! ğŸ˜Ÿ I'm sorry you're not feeling well! ğŸ¤’ Here's what you can do:

**For your headache and fever:** ğŸ’Š

1. ğŸ›ï¸ **Rest** - Your body needs time to recover!
2. ğŸ’§ **Stay hydrated** - Drink lots of water, herbal tea, or clear broths
3. ğŸŒ¡ï¸ **Monitor your temperature** - Keep track of your fever
4. ğŸ’Š **Take acetaminophen or ibuprofen** - Follow package directions for fever/pain relief
5. ğŸ§Š **Cool compress** - Place on forehead for headache relief
6. ğŸŒ™ **Sleep in a dark, quiet room** - Helps with headache

**âš ï¸ SEEK MEDICAL ATTENTION IF:**
- Fever over 103Â°F (39.4Â°C) ğŸŒ¡ï¸
- Severe headache unlike any you've had before ğŸ¤•
- Stiff neck or confusion ğŸ˜µ
- Fever lasts more than 3 days ğŸ“…
- Difficulty breathing ğŸ˜®â€ğŸ’¨

Feel better soon! ğŸŒŸ And remember, I'm not a substitute for professional medical advice! ğŸ‘¨â€âš•ï¸ğŸ‘©â€âš•ï¸

```

**What Happened:**

1. Main agent received: "I am feeling headache and feverish. What should I do?"
2. Main agent reasoned: "This is a medical/health question"
3. Main agent checked handoffs: "I have a Doctor Agent for this"
4. Main agent handed off to doctor_agent
5. Doctor agent responded in its distinctive style (emoji-filled)
6. Response came back through the main agent to the user

## The Handoff Mechanism Deep Dive

Let's understand what's happening during a handoff:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER                                                        â”‚
â”‚ "What's a good recipe for pasta?"                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MAIN AGENT (Router)                                         â”‚
â”‚ - Analyzes query: "This is about cooking"                  â”‚
â”‚ - Reviews handoffs: [Chef Agent, Doctor Agent]             â”‚
â”‚ - Matches to Chef Agent                                     â”‚
â”‚ - Decides: "Hand off to Chef Agent"                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HANDOFF EXECUTION                                           â”‚
â”‚ - Framework transfers control to Chef Agent                 â”‚
â”‚ - Chef Agent receives full conversation context            â”‚
â”‚ - Chef Agent becomes active responder                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CHEF AGENT (Specialist)                                     â”‚
â”‚ - Processes query with its instructions                     â”‚
â”‚ - Generates response in ALL CAPS                            â”‚
â”‚ - Returns detailed recipe                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RESPONSE TO USER                                            â”‚
â”‚ Recipe in ALL CAPS (Chef's style)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```

### Key Points About Handoffs

**1. Context is Preserved**

When handing off, the specialized agent receives:

- Full conversation history
- User's original query
- Any relevant context from previous turns

**2. Instructions Override**

Once handed off, the specialist's instructions take over:

- Chef agent will respond in CAPS
- Doctor agent will use emojis
- Each agent's personality is preserved

**3. One Active Agent at a Time**

The framework ensures:

- Only one agent is actively responding
- No conflicts between agents
- Clear ownership of each response

**4. Memory Includes Handoffs**

The conversation history tracks:

```python
[
    {"role": "user", "content": "What's a recipe for pasta?"},
    {"role": "assistant", "content": "...", "agent": "main_agent"},  # Decision to handoff
    {"role": "assistant", "content": "HERE'S A RECIPE...", "agent": "chef_agent"}  # Chef's response
]

```

## Designing Effective Agent Teams

### Principle 1: Clear Domain Boundaries

Each agent should have a well-defined domain:

âœ… Good:

- Chef Agent: Recipes, cooking techniques, ingredients
- Doctor Agent: Health symptoms, medical information
- Finance Agent: Budgeting, investments, financial planning

âŒ Bad:

- Agent 1: Recipes and medical advice (too broad, conflicting)
- Agent 2: Everything else (no clear boundary)

### Principle 2: Complementary Capabilities

Agents should cover different needs:

```python
# Good team composition
customer_service_agent  # Handles general inquiries
technical_support_agent  # Handles technical issues
billing_agent           # Handles payments and subscriptions

```

### Principle 3: Distinctive Personalities (When Appropriate)

For user-facing systems, personality differentiation helps:

```python
sales_agent = Agent(
    instructions="You are enthusiastic, positive, and solution-focused."
)

support_agent = Agent(
    instructions="You are patient, empathetic, and detail-oriented."
)

```

### Principle 4: Appropriate Tool Access

Each agent should only access relevant tools:

```python
chef_agent = Agent(
    instructions="...",
    tools=[recipe_search, nutrition_calculator, cooking_timer]
)

doctor_agent = Agent(
    instructions="...",
    tools=[symptom_checker, drug_interactions, medical_database]
)

```

Don't give the chef agent access to medical databases, or vice versa.

## Memory Across Agent Switches

One powerful aspect of this architecture: **memory persists across handoffs**.

Consider this conversation flow:

```python
# Turn 1: User talks to main agent
await ask_agent("Hi, I'm planning a dinner party")

# Turn 2: Hands off to chef
await ask_agent("What should I serve?")
# Chef knows about the dinner party from conversation history

# Turn 3: Back to main agent
await ask_agent("Thanks! Now I need help with something else")

# Turn 4: Hands off to doctor
await ask_agent("I have a headache")
# Doctor can see the full conversation, including chef interaction

```

Each agent can see the entire conversation history, providing continuity even as control switches between specialists.

## When Agents Don't Hand Off

Not every query requires a handoff:

**Scenario: Meta Questions**

```python
await ask_agent("What can you help me with?")
# Main agent responds directly - no handoff needed

```

**Scenario: Ambiguous Queries**

```python
await ask_agent("Tell me about Italy")
# Main agent might respond: "I can help with Italian recipes or Italian healthcare system. Which interests you?"

```

**Scenario: Already With Specialist**

If you're already talking to the chef agent and ask another recipe question, there's no need to hand offâ€”you're already with the right agent.

## Common Multi-Agent Patterns

### Pattern 1: Hub and Spoke

One main router, multiple specialists:

```
        [Main Agent]
        /    |    \
    [Chef] [Doc] [Finance]

```

### Pattern 2: Sequential Workflow

Agents work in sequence:

```
[Intake] â†’ [Research] â†’ [Analysis] â†’ [Reporting]

```

### Pattern 3: Peer Agents

Agents can hand off to each other:

```
[Agent A] â†â†’ [Agent B]
    â†“  â†˜    â†—  â†“
    [Agent C] [Agent D]

```

### Pattern 4: Hierarchical

Managers coordinate specialist teams:

```
     [Manager]
        â†“
    [Supervisor]
    /    |    \
[A]    [B]    [C]

```

## Limitations and Considerations

### Challenge 1: Handoff Overhead

Each handoff involves:

- Decision-making by the router
- Context transfer
- Additional LLM calls

For simple queries, multiple agents might be overkill.

### Challenge 2: Consistency

Different agents might give different answers to similar questions. Ensure alignment through:

- Shared knowledge bases
- Consistent training
- Regular testing

### Challenge 3: Handoff Decisions

The router agent needs to make good decisions. Poor routing leads to:

- User frustration
- Multiple unnecessary handoffs
- Reduced efficiency

### Challenge 4: Cost

More agents = more LLM calls = higher costs. Balance specialization with efficiency.

## What We've Built

Today we've created a multi-agent system with:

- âœ… Multiple specialized agents with distinct personalities
- âœ… A main router agent that coordinates specialists
- âœ… Handoff mechanism for transferring control
- âœ… Persistent memory across agent switches
- âœ… Clear domain boundaries and responsibilities
- âœ… Autonomous handoff decisions

## What's Next

We now have multiple agents that can handle different domains. But our current system has a limitation: the main agent makes all routing decisions upfront.

What if we need more sophisticated coordination? What if agents need to:

- Collaborate on complex tasks
- Hand off back and forth
- Escalate to supervisors
- Work in parallel

In the next blog, we'll explore **handoffs with orchestrator agents**â€”sophisticated routing and coordination patterns that enable complex multi-agent workflows.

After that, we'll build a **complete agentic backend**, bringing together everything we've learned into a production-ready system.

---

*Next: Handoff Using Orchestrator Agentâ€”advanced coordination patterns for complex multi-agent systems.*