# 8. Agent as a Tool: Building Hierarchical AI for Content Creation

In the sophisticated world of AI agents, the ability to specialize tasks leads to more robust and efficient systems. We've explored how a single agent can leverage external tools, and how an orchestrator can delegate entire conversations via "handoffs." Now, let's delve into an even more powerful pattern: treating an **entire agent as a callable tool** for another agent.

This concept allows you to build deeply hierarchical AI systems, where a high-level "manager" agent can invoke a specialized "worker" agent as a simple function, getting a specific job done without completely transferring control. It's like a project manager assigning a task to a specialist and receiving a clear, concise result back, while remaining in charge of the overall project.

Let's set up our foundational components, which will be shared across all our agents:

```python
import asyncio
from openai import AsyncAzureOpenAI
from agents import Agent, Runner, OpenAIChatCompletionsModel, function_tool # Assuming function_tool or similar handles as_tool()
import os
from dataclasses import dataclass

# ===== Shared User Info Dataclass (for context) =====
@dataclass
class UserInfo:
    email: str
    user_id: str
    session_id: str
    # Add other relevant user or session context here

# ===== Shared Azure OpenAI Client (The LLM brain for all agents) =====
agent_client = AsyncAzureOpenAI(
    api_key=os.getenv("GPT_4_O_AZURE_OPENAI_API_KEY"),
    api_version=os.getenv("GPT_4_O_AZURE_OPENAI_API_VERSION"),
    azure_endpoint=os.getenv("GPT_4_O_AZURE_OPENAI_API_ENDPOINT"),
    azure_deployment=os.getenv("GPT_4_O_AZURE_OPENAI_API_MODEL_NAME"),
)

model_name = os.getenv("GPT_4_O_AZURE_OPENAI_API_MODEL_NAME")

# ===== Placeholder for a "real" creative content generation tool =====
# This simulates an actual tool that the Image Generation Agent might call internally.
@function_tool
def internal_image_generator_tool(prompt: str, style: str = "realistic", size: str = "1024x1024") -> str:
    """
    Generates an image based on the given prompt, style, and size.
    This is an internal tool used by the Image Generation Agent.
    """
    print(f"DEBUG: Internal image generation tool called with prompt: '{prompt}', style: '{style}', size: '{size}'")
    # In a real scenario, this would integrate with DALL-E, Midjourney, etc.
    return f"Image URL for: '{prompt}' (style: {style}, size: {size})"

# ===== Placeholder for a "real" research tool for the blog writer =====
@function_tool
def internal_research_tool(query: str) -> str:
    """
    Performs research on a given query to gather information for writing.
    """
    print(f"DEBUG: Internal research tool called with query: '{query}'")
    return f"Research results for: '{query}' (e.g., summary of articles on the topic)"
```

---

### The Specialist Agents: Our Content Creators

First, we define our individual expert agents. Each one has a clear, focused purpose. They are complete AI agents in themselves, capable of reasoning and executing tasks within their specific domain.

### 1. The Image Generation Agent

This agent's sole purpose is to understand requests for visual content and formulate the best possible prompt for an underlying image generation system.

```python
# ===== Image Generation Agent Definition =====
image_generation_agent = Agent[UserInfo](
    name="Image Generator",
    instructions=(
        "You are an expert image prompt generator. Your task is to take a user's request "
        "for an image and expand it into a detailed, vivid, and highly descriptive prompt "
        "suitable for a state-of-the-art image generation model. Focus on style, setting, "
        "lighting, subject details, and overall mood. You can also use your internal_image_generator_tool "
        "to simulate image creation."
    ),
    model=OpenAIChatCompletionsModel(
        model=model_name,
        openai_client=agent_client
    ),
    tools=[internal_image_generator_tool], # It has its own internal tool
)
```

### 2. The Blog Writing Agent

This agent specializes in crafting engaging and coherent blog posts. It takes a topic and potentially additional research or outline points, and then generates the complete textual content.

```python
# ===== Blog Writing Agent Definition =====
blog_writing_agent = Agent[UserInfo](
    name="Blog Writer",
    instructions=(
        "You are a professional blog post writer. Your goal is to create well-structured, "
        "informative, and engaging blog content based on the provided topic. Ensure clarity, "
        "flow, and adherence to standard blog formats (intro, body paragraphs, conclusion). "
        "You can use your internal_research_tool for gathering information."
    ),
    model=OpenAIChatCompletionsModel(
        model=model_name,
        openai_client=agent_client
    ),
    tools=[internal_research_tool], # It has its own internal tool for research
)
```

---

### The Orchestrator: Agent as a Tool in Action

Now, we define our `ContentCreatorAgent`. This agent is an orchestrator, but instead of simply "handing off" control and stepping aside, it "calls" our specialist agents as if they were functions. This allows the `ContentCreatorAgent` to remain in control, integrating the results from its sub-agents into a larger, more complex output.

The magic happens with the `.as_tool()` method. This method transforms an entire `Agent` instance into a `Tool` object that can be added to another agent's `tools` list.

```python
# ===== The Orchestrator Agent Definition =====
content_creator_orchestrator = Agent[UserInfo](
    name="Content Creator Orchestrator",
    instructions=(
        "You are a versatile content creation orchestrator. Your primary role is to "
        "understand the user's content needs and dispatch tasks to specialized agents "
        "by calling them as tools. "
        "If the user asks for an image, use the `create_image_content` tool. "
        "If the user asks for a blog post, use the `generate_blog_post` tool. "
        "You must respond with the output from the tool call."
    ),
    model=OpenAIChatCompletionsModel(
        model=model_name,
        openai_client=agent_client
    ),
    tools=[
        # Here, we transform our specialist agents into callable tools
        image_generation_agent.as_tool(
            tool_name="create_image_content",
            tool_description="Creates a detailed image prompt and simulates image generation for a given visual description.",
        ),
        blog_writing_agent.as_tool(
            tool_name="generate_blog_post",
            tool_description="Generates a full blog post on a specified topic.",
        ),
    ],
    handoffs=[], # No direct handoffs in this orchestrator; it calls agents as tools.
)
```

In this setup:

- The `content_creator_orchestrator`'s LLM, guided by its instructions, now sees `create_image_content` and `generate_blog_post` as available functions it can call.
- When the LLM decides to "call" `create_image_content`, it's actually invoking the `image_generation_agent` to perform its task. The `image_generation_agent` will then use its *own* internal tools (`internal_image_generator_tool` in this case) and return a result back to the `content_creator_orchestrator`.
- Similarly, calling `generate_blog_post` activates the `blog_writing_agent`.

---

### Running the Hierarchical System

Let's see how our orchestrator would use these "agent-tools":

```python
async def main():
    user_info = UserInfo(
        email="test@example.com",
        user_id="user123",
        session_id="sessionXYZ"
    )

    print("--- Requesting an Image ---")
    image_result = await Runner.run(
        content_creator_orchestrator,
        input="Please create an image of a futuristic cityscape at sunset.",
        context=user_info
    )
    print(f"\nOrchestrator's Image Output: {image_result.final_output}\n")

    print("--- Requesting a Blog Post ---")
    blog_result = await Runner.run(
        content_creator_orchestrator,
        input="Write a short blog post about the benefits of modular AI agents.",
        context=user_info
    )
    print(f"\nOrchestrator's Blog Output: {blog_result.final_output}\n")

# To run this example:
# if __name__ == "__main__":
#     asyncio.run(main())
```

---

### Why This Architecture Matters

The "Agent as a Tool" pattern is a cornerstone for building truly sophisticated AI applications:

- **Hierarchical Decomposition:** It allows you to break down immense problems into smaller, manageable sub-problems, each handled by a specialized agent.
- **Encapsulation and Abstraction:** The orchestrator doesn't need to know the inner workings of the specialist agents; it just needs their tool interface (name, description, parameters). This simplifies the orchestrator's logic.
- **Reusability:** Specialist agents (like our `Image Generator` and `Blog Writer`) can be developed once and then plugged into various orchestrators or even other specialist agents as tools, promoting code reuse across different AI workflows.
- **Maintainability and Debugging:** Issues can be isolated to specific agents or their internal tools, making debugging and updates far more manageable in complex systems.
- **Scalability:** Different agents can potentially run on different resources or scale independently based on demand, optimizing performance and cost.

By embracing the "Agent as a Tool" paradigm, you unlock the full potential of multi-agent systems, enabling you to design and implement AI solutions that are not only intelligent but also structured, robust, and scalable. This is the future of building complex AI-powered applications.