# Building an Entire Agentic AI Backend: From Components to Production System

We've learned the fundamentals: agents, memory, tools, context, and handoffs. We've built specialized agents that can collaborate. Now it's time to bring everything together into a **complete agentic backend**â€”a production-ready system that can handle diverse user requests through intelligent orchestration.

In this blog, we'll architect and build a comprehensive multi-agent system that serves as a personal AI assistant, capable of writing content, generating code, creating images, analyzing documents, and searching through work dataâ€”all autonomously coordinated through a single entry point.

## The Vision: A Complete AI Assistant Backend

Imagine an AI system that can:

- **Write content**: Blog posts, articles, documentation
- **Generate code**: Any programming language, any framework
- **Create images**: Visual content from text descriptions
- **Analyze data**: Generate charts, summaries, insights
- **Search workspace**: Files, emails, calendar, messages

All through natural language conversations, with the system autonomously deciding which specialist to engage.

This is what we're building today.

## System Architecture Overview

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   USER INPUT        â”‚
                    â”‚  (Natural Language) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   MAIN AGENT        â”‚
                    â”‚   (Orchestrator)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â†“            â†“         â†“         â†“            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Content   â”‚ â”‚  Coding   â”‚ â”‚ Image  â”‚ â”‚Documentâ”‚ â”‚  Work  â”‚
â”‚ Writer    â”‚ â”‚  Agent    â”‚ â”‚ Agent  â”‚ â”‚Analyst â”‚ â”‚ Agent  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“              â†“           â†“          â†“          â†“
  [No Tools]   [No Tools]  [gen_image] [create_  [search_*]
                                        chart]    [4 tools]

```

## Setting Up the Foundation

Let's start with our familiar setup, now with user context:

```python
import os
from dataclasses import dataclass
from agents import Agent, function_tool, RunContextWrapper, handoff, Runner
from openai import AsyncAzureOpenAI

# Azure OpenAI Client
agent_client = AsyncAzureOpenAI(
    api_key=os.getenv("GPT_4_1_AZURE_OPENAI_API_KEY"),
    api_version=os.getenv("GPT_4_1_AZURE_OPENAI_API_VERSION"),
    azure_endpoint=os.getenv("GPT_4_1_AZURE_OPENAI_API_ENDPOINT"),
    azure_deployment=os.getenv("GPT_4_1_AZURE_OPENAI_API_MODEL_NAME"),
)

model_name = os.getenv("GPT_4_1_AZURE_OPENAI_API_MODEL_NAME")

# User Context Definition
@dataclass
class UserInfo:
    user_name: str
    user_api_key: str

```

We're using the context wrapper pattern from Blog #8. Each agent will have access to user-specific information through `RunContextWrapper[UserInfo]`.

## Building the Specialist Agents

### Agent 1: Content Writer (No Tools)

```python
content_writer_agent = Agent[UserInfo](
    name="Content Writer Agent",
    instructions=(
        "You are a professional content writer. "
        "You write clear, structured, high-quality blog posts, articles, and documents. "
        "For any writing task, produce engaging, well-formatted content."
    ),
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
)

```

**What It Does:**

- Writes blog posts, articles, reports
- Creates structured, engaging content
- No external tools neededâ€”uses pure language generation

**When to Use:**

- "Write a blog about X"
- "Create an article on Y"
- "Draft a report about Z"

**Why No Tools?**

Content writing is a pure generation task. The LLM's training data and language capabilities are sufficient. Adding tools would just add complexity without benefit.

### Agent 2: Coding Agent (No Tools)

```python
coding_agent = Agent[UserInfo](
    name="Coding Agent",
    instructions=(
        "You are an elite software engineer. "
        "You write clean, production-quality code with best practices and clear explanations. "
        "Respond to user requests by providing optimized code snippets in the requested language."
    ),
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
)

```

**What It Does:**

- Generates code in any language
- Follows best practices and patterns
- Provides explanations and documentation

**When to Use:**

- "Write Python code for X"
- "Create a React component that Y"
- "Generate SQL query to Z"

**Why No Tools?**

Like content writing, code generation leverages the model's training. You could add tools for code execution, testing, or linting, but for basic code generation, they're unnecessary.

### Agent 3: Image Generator (With Tool)

```python
@function_tool
def generate_image(wrapper: RunContextWrapper[UserInfo], prompt: str) -> dict:
    """
    Return a fixed, realistic image URL (Unsplash example).
    """
    image_url = "https://images.unsplash.com/photo-1506744038136-46273834b3fb"
    return {"prompt": prompt, "image_url": image_url}

image_generator_agent = Agent[UserInfo](
    name="Image Generator Agent",
    instructions="You generate or fetch images for any prompt using tools.",
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
    tools=[generate_image]
)

```

**What It Does:**

- Generates or fetches images based on prompts
- Returns image URLs for display

**When to Use:**

- "Generate an image of X"
- "Create a picture showing Y"
- "Find an image that represents Z"

**The Tool:**

In this implementation, we're using a placeholderâ€”returning a fixed Unsplash URL. In production, you'd integrate with:

- DALL-E API for AI image generation
- Stable Diffusion for local generation
- Image search APIs for finding existing images
- Stock photo services

The structure remains the same; only the implementation changes.

**Why It Needs a Tool:**

Unlike text generation, image creation requires external services. The LLM can understand the prompt but can't generate image data itselfâ€”it needs to call an external API.

### Agent 4: Document Analyst (With Tool)

```python
@function_tool
def create_chart(wrapper: RunContextWrapper[UserInfo], data_description: str) -> dict:
    """
    Return a fixed chart URL.
    """
    chart_url = "https://quickchart.io/chart?c={type:'bar',data:{labels:['A','B','C'],datasets:[{label:'Data',data:[10,20,30]}]}}"
    return {"description": data_description, "chart_url": chart_url}

document_analyst_agent = Agent[UserInfo](
    name="Document Analyst Agent",
    instructions="You analyze documents and data, and create charts or summaries as needed.",
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
    tools=[create_chart]
)

```

**What It Does:**

- Analyzes documents and data
- Creates visualizations (charts, graphs)
- Generates summaries and insights

**When to Use:**

- "Analyze this sales data"
- "Create a chart from Q3 results"
- "Summarize this document"

**The Tool:**

Again, we're using a placeholderâ€”returning a fixed QuickChart URL. In production, you'd:

- Process actual data
- Generate dynamic charts
- Create custom visualizations
- Support multiple chart types

**Why It Needs a Tool:**

While the agent can analyze data conceptually, creating actual visualizations requires external rendering services or libraries.

### Agent 5: Work Agent (With Multiple Tools)

This is our most complex agentâ€”it has access to four different tools for searching workspace data:

```python
@function_tool
def search_files(wrapper: RunContextWrapper[UserInfo], query: str) -> list:
    user = wrapper.context.user_name
    return [
        {"file_name": f"{user}_Quarterly_Report_Q3.pdf", "path": f"/drive/{user}/reports/Q3_Report.pdf"},
        {"file_name": f"{user}_AI_Strategy.docx", "path": f"/drive/{user}/strategy/AI_Strategy.docx"}
    ]

@function_tool
def search_emails(wrapper: RunContextWrapper[UserInfo], query: str) -> list:
    user = wrapper.context.user_name
    return [
        {"from": "ceo@company.com", "to": user, "subject": "Q3 Results", "snippet": "Great job team..."},
        {"from": "hr@company.com", "to": user, "subject": "Policy Updates", "snippet": "Please review the attached..."}
    ]

@function_tool
def search_calendar(wrapper: RunContextWrapper[UserInfo], query: str) -> list:
    user = wrapper.context.user_name
    return [
        {"user": user, "event": "AI Workshop", "date": "2025-10-05", "time": "10:00 AM"},
        {"user": user, "event": "Team Standup", "date": "2025-10-06", "time": "09:30 AM"}
    ]

@function_tool
def search_messages(wrapper: RunContextWrapper[UserInfo], query: str) -> list:
    user = wrapper.context.user_name
    return [
        {"user": user, "from": "Jane", "message": "Did you check the new PR?"},
        {"user": user, "from": "DevOps", "message": "Deployment completed successfully."}
    ]

work_agent = Agent[UserInfo](
    name="Work Agent",
    instructions="You can search through files, emails, calendar events, and messages for the user.",
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
    tools=[search_files, search_emails, search_calendar, search_messages]
)

```

**What It Does:**

- Searches through files (documents, PDFs)
- Queries emails and threads
- Finds calendar events
- Searches message history

**When to Use:**

- "Find files about project X"
- "Search my emails for Y"
- "What meetings do I have this week?"
- "Find messages from person Z"

**The Tools:**

Notice how all four tools use `wrapper.context.user_name` to personalize results. This demonstrates the power of context wrappersâ€”each user gets their own data without the tools needing to manage user authentication explicitly.

In production, these would:

- Connect to Google Drive, OneDrive, or SharePoint
- Integrate with Gmail, Outlook, or Slack
- Query Google Calendar or Microsoft Calendar
- Search messaging platforms like Slack or Teams

**Why Multiple Tools?**

Each tool searches a different data source. The agent can:

- Choose the right tool for each query
- Call multiple tools if needed ("Find files and emails about X")
- Combine results intelligently

## The Orchestrator: Main Agent

Now we tie it all together:

```python
main_agent = Agent[UserInfo](
    name="Main Agent",
    instructions="You are the orchestrator. Route user queries to the most appropriate agent.",
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
    handoffs=[
        handoff(content_writer_agent),
        handoff(coding_agent),
        handoff(image_generator_agent),
        handoff(document_analyst_agent),
        handoff(work_agent),
    ]
)

```

**The Main Agent's Job:**

1. **Receive all user queries**
2. **Analyze intent**: What is the user trying to accomplish?
3. **Select specialist**: Which agent can best handle this?
4. **Hand off**: Transfer control to the chosen agent
5. **Return results**: Deliver the specialist's response to the user

**Key Design Decision:**

Notice the minimal instructions: "You are the orchestrator. Route user queries to the most appropriate agent."

The main agent isn't trying to be smart about content or codeâ€”it's a **pure router**. Its only job is matching queries to specialists.

## Setting Up User Context and Memory

```python
my_user_info = UserInfo(
    user_name="Sai Ram Penjarla",
    user_api_key="DUMMY-API-KEY"
)

messages = []

async def ask_agent(query: str):
    global messages
    input_msg = [{"role": "user", "content": query}]
    result = await Runner.run(main_agent, input=messages + input_msg, context=my_user_info)
    messages = result.to_input_list()
    display(Markdown(result.final_output))

```

**What's Happening:**

- **User Context**: Created once per user session
- **Memory**: Maintains conversation history across all agent interactions
- **Context Passing**: Every tool call gets user context automatically
- **Memory Preservation**: History includes all handoffs and responses

## The System in Action

### Scenario 1: Content Writing

```python
await ask_agent("Write a blog on Generative AI in Manufacturing")

```

**Execution Flow:**

1. **Main agent receives**: "Write a blog on Generative AI in Manufacturing"
2. **Analysis**: "This is a content writing task"
3. **Decision**: Hand off to Content Writer Agent
4. **Content Writer Agent**: Generates comprehensive blog post
5. **Response**: Full blog post with sections, insights, examples

**Expected Output:**

```markdown
# Generative AI in Manufacturing: Transforming the Factory Floor

The manufacturing industry is experiencing a revolution driven by Generative AI...

## The Impact on Production

Generative AI is enabling manufacturers to:
- Optimize production schedules using predictive models
- Design new products through AI-assisted CAD
- Predict maintenance needs before failures occur
- Improve quality control with vision systems

## Real-World Applications

Companies like Siemens and BMW are already deploying...

[Continues with detailed, well-structured content]

```

**Key Point:** The content writer agent uses pure generationâ€”no tools needed, just excellent writing.

### Scenario 2: Code Generation

```python
await ask_agent("Generate HTML code for a simple login page")

```

**Execution Flow:**

1. **Main agent receives**: "Generate HTML code for a simple login page"
2. **Analysis**: "This is a coding task"
3. **Decision**: Hand off to Coding Agent
4. **Coding Agent**: Generates HTML with best practices
5. **Response**: Complete, functional code

**Expected Output:**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login Page</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .login-container {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            width: 300px;
        }
        /* Additional styling... */
    </style>
</head>
<body>
    <div class="login-container">
        <h2>Login</h2>
        <form id="loginForm">
            <input type="email" placeholder="Email" required>
            <input type="password" placeholder="Password" required>
            <button type="submit">Login</button>
        </form>
    </div>
</body>
</html>

```

**Key Point:** The coding agent generates production-ready code with proper structure, styling, and semantics.

### Scenario 3: Image Generation

```python
await ask_agent("Generate an image of a futuristic factory")

```

**Execution Flow:**

1. **Main agent receives**: "Generate an image of a futuristic factory"
2. **Analysis**: "This requires image generation"
3. **Decision**: Hand off to Image Generator Agent
4. **Image Generator Agent**:
    - Calls `generate_image("futuristic factory")`
    - Receives image URL from tool
    - Formats response with image link
5. **Response**: Image URL and description

**Expected Output:**

```
I've generated an image of a futuristic factory for you!

![Futuristic Factory](https://images.unsplash.com/photo-1506744038136-46273834b3fb)

The image shows an advanced manufacturing facility with automated systems
and modern technology.

```

**Key Point:** The agent uses its tool to fetch/generate the image, then presents it with context.

### Scenario 4: Data Visualization

```python
await ask_agent("Create a chart from sales data of Q3")

```

**Execution Flow:**

1. **Main agent receives**: "Create a chart from sales data of Q3"
2. **Analysis**: "This requires data analysis and visualization"
3. **Decision**: Hand off to Document Analyst Agent
4. **Document Analyst Agent**:
    - Calls `create_chart("Q3 sales data")`
    - Receives chart URL from tool
    - Formats response with visualization
5. **Response**: Chart URL and insights

**Expected Output:**

```
Here's a chart visualizing the Q3 sales data:

![Q3 Sales Chart](https://quickchart.io/chart?c={...})

Key insights:
- Sales showed steady growth through Q3
- Peak performance in September
- Category A outperformed expectations

```

**Key Point:** The agent combines tool output (chart) with analytical insights (interpretation).

### Scenario 5: Workspace Search

```python
await ask_agent("Search my calendar for AI events")

```

**Execution Flow:**

1. **Main agent receives**: "Search my calendar for AI events"
2. **Analysis**: "This is a workspace searchâ€”calendar specific"
3. **Decision**: Hand off to Work Agent
4. **Work Agent**:
    - Calls `search_calendar("AI events")`
    - Receives calendar data for user "Sai Ram Penjarla"
    - Formats results nicely
5. **Response**: Formatted calendar events

**Expected Output:**

```
I found these AI-related events in your calendar:

ðŸ“… **AI Workshop**
   Date: October 5, 2025
   Time: 10:00 AM

ðŸ“… **Team Standup** (may include AI discussions)
   Date: October 6, 2025
   Time: 09:30 AM

Would you like me to search for more events or get details about any of these?

```

**Key Point:** The work agent uses context (`wrapper.context.user_name`) to return user-specific results.

## Multi-Tool Coordination

The work agent can coordinate multiple tools:

```python
await ask_agent("Find everything about 'AI Strategy' - files, emails, calendar, and messages")

```

**Execution Flow:**

1. **Main agent**: Hands off to Work Agent
2. **Work Agent decides**: "Need to search multiple sources"
3. **Sequential tool calls**:
    - `search_files("AI Strategy")`
    - `search_emails("AI Strategy")`
    - `search_calendar("AI Strategy")`
    - `search_messages("AI Strategy")`
4. **Synthesizes results**: Combines all findings
5. **Response**: Comprehensive report

**Expected Output:**

```
Here's everything I found about 'AI Strategy':

ðŸ“ **Files (2 found):**
- AI_Strategy.docx (/drive/Sai Ram Penjarla/strategy/)
- Quarterly_Report_Q3.pdf (mentions AI strategy)

ðŸ“§ **Emails (1 found):**
From: ceo@company.com
Subject: Q3 Results
Snippet: "Great job team... our AI strategy is paying off..."

ðŸ“… **Calendar Events (1 found):**
- AI Workshop on Oct 5, 2025 at 10:00 AM

ðŸ’¬ **Messages (0 found):**
No direct messages found about AI Strategy.

Would you like me to open any of these files or provide more details?

```

This demonstrates sophisticated orchestrationâ€”one agent autonomously coordinating multiple tools to fulfill a complex request.

## System Architecture Benefits

### 1. Separation of Concerns

Each agent focuses on its domain:

- Content writer â†’ Writing
- Coder â†’ Code generation
- Image generator â†’ Visual content
- Document analyst â†’ Data analysis
- Work agent â†’ Information retrieval

### 2. Scalability

Easy to add new agents:

```python
translation_agent = Agent[UserInfo](
    name="Translation Agent",
    instructions="You translate text between languages",
    ...
)

# Add to main agent's handoffs
handoffs=[..., handoff(translation_agent)]

```

### 3. Maintainability

Update agents independently:

- Improve content writer's instructions
- Add tools to work agent
- Update image generation API
- No impact on other agents

### 4. Testability

Test each agent in isolation:

```python
# Test content writer
result = await Runner.run(
    content_writer_agent,
    input="Write about AI",
    context=test_user_info
)

# Test coding agent separately
result = await Runner.run(
    coding_agent,
    input="Generate Python function",
    context=test_user_info
)

```

### 5. Resource Optimization

Different agents can use:

- Different models (GPT-4 for coding, GPT-3.5 for routing)
- Different rate limits
- Different caching strategies
- Different cost profiles

### 6. User Personalization

Context flows to all agents:

- User-specific file searches
- Personalized email queries
- Individual calendar access
- Custom preferences

## Production Considerations

### Error Handling

```python
@function_tool
def search_files(wrapper: RunContextWrapper[UserInfo], query: str) -> list:
    try:
        user = wrapper.context.user_name
        # Actual file search logic
        return results
    except Exception as e:
        return {
            "error": True,
            "message": f"Failed to search files: {str(e)}"
        }

```

### Rate Limiting

```python
@dataclass
class UserInfo:
    user_name: str
    user_api_key: str
    requests_remaining: int  # Track API quota

# Check in tools:
if wrapper.context.requests_remaining <= 0:
    return {"error": "API quota exceeded"}

```

### Logging and Monitoring

```python
import logging

async def ask_agent(query: str):
    logging.info(f"User {my_user_info.user_name} asked: {query}")
    result = await Runner.run(main_agent, input=messages + input_msg, context=my_user_info)
    logging.info(f"Response from: {result.active_agent_name}")
    return result

```

### Caching

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def get_cached_search_results(user: str, query: str):
    # Cache expensive searches
    return search_results

```

### Security

```python
@function_tool
def search_files(wrapper: RunContextWrapper[UserInfo], query: str) -> list:
    user = wrapper.context.user_name

    # Validate user permissions
    if not has_file_access(user):
        return {"error": "Permission denied"}

    # Sanitize query
    safe_query = sanitize_input(query)

    # Execute with user's permissions
    return execute_search(user, safe_query)

```

## What We've Built

This is a complete agentic backend with:

- âœ… **5 specialized agents** with distinct capabilities
- âœ… **7 tools** across 3 agents for real-world interactions
- âœ… **User context** flowing through all operations
- âœ… **Memory persistence** across all agent switches
- âœ… **Intelligent orchestration** via main router agent
- âœ… **Scalable architecture** easy to extend
- âœ… **Production patterns** for error handling, security, logging

## Real-World Applications

This architecture can power:

### Personal AI Assistant

- Schedule management
- Email drafting and responses
- Document creation and analysis
- Information retrieval

### Enterprise Support System

- Customer service routing
- Technical support
- Sales assistance
- HR inquiries

### Development Platform

- Code generation and review
- Documentation creation
- Test writing
- Deployment assistance

### Creative Studio

- Content creation
- Image generation
- Video script writing
- Social media management

### Data Platform

- Report generation
- Visualization creation
- Data analysis
- Insight extraction

## What's Next

We now have a complete agentic system, but operating it in production comes with challenges. In the final blog of this series, we'll explore **common problems in agent orchestration** and their solutions:

- Handoff loops (agents passing control back and forth)
- Context overflow (hitting token limits)
- Tool failures and error recovery
- Cost optimization strategies
- Performance bottlenecks
- Debugging complex interactions
- Testing strategies
- Monitoring and observability

---

*Next: Common Problems While Building Agent Orchestrationâ€”identifying and solving production challenges.*