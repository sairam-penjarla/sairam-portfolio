# 4. Understanding Context Wrapper in AI Agents

In our previous discussions, we've explored what AI agents are, how they use tools, and how to build and connect those tools. A key element that allows agents to operate intelligently and persistently is their ability to manage **context**. This isn't just about remembering past conversations; it's about providing relevant, dynamic information to the agent and its tools at precisely the right moment. This is where the `RunContextWrapper` comes into play.

---

### What is `RunContextWrapper`?

At its core, a `RunContextWrapper` (or a similar construct in other AI agent frameworks) is a container that holds **contextual data** for an agent's execution. Think of it as a specialized briefcase that gets passed along during an agent's "thinking" and "acting" process, ensuring all necessary information is readily available.

It's typically a wrapper around a custom Python object that you define, designed to carry any piece of data that might be relevant to the current interaction or the agent's overall task.

### Your Custom Context: The `UserInfo` `dataclass`

In our previous examples, we introduced a `UserInfo` `dataclass`:

```python
from dataclasses import dataclass

@dataclass
class UserInfo:
    email: str
    auth_access_token: str
    entra_id_user_id: str
    user_id: str
    session_id: str
```

- **`@dataclass`**: This Python decorator is perfect for defining simple data-holding classes like `UserInfo`. It automatically generates common methods like `__init__`, `__repr__`, and `__eq__`, reducing boilerplate code. This makes `UserInfo` easy to create and use.
- **Purpose of `UserInfo`**: This specific `dataclass` is designed to carry details about the *current user* and their *session*. This might include their email, authentication tokens, unique user IDs, and session identifiers. These pieces of information are crucial for personalizing responses, ensuring secure tool interactions, and logging agent activity.

When you pass an instance of `UserInfo` to your agent, the framework wraps it within a `RunContextWrapper`. So, when your tool function receives `wrapper: RunContextWrapper[UserInfo]`, it can then access your custom context object via `wrapper.context` (e.g., `wrapper.context.user_id`).

---

### Why is `RunContextWrapper` Used? The Benefits of Context Injection

The `RunContextWrapper` pattern offers significant advantages for building robust and scalable AI agents:

1. **Dependency Injection:**
    - **What it is:** Instead of a tool or agent component creating its own dependencies (like an OpenAI client, a database connection, or a custom utility class), these dependencies are "injected" or provided externally via the context.
    - **Why it's used:** This promotes modularity and testability. Your tools become pure functions that operate on provided inputs and context, without needing to worry about how to initialize external services. You can easily swap out real services for mock objects during testing.
2. **State Management:**
    - **What it is:** While agents maintain conversational memory (chat history), the context wrapper allows you to manage *additional* state that's relevant to the current "run" but might not be part of the core LLM prompt. This includes user preferences, temporary flags, or accumulated data from previous tool calls within a single, multi-step interaction.
    - **Why it's used:** It ensures that consistent, relevant data is available throughout a complex agent workflow, even across multiple turns or tool invocations.
3. **Traceability and Logging:**
    - **What it is:** The context can carry identifiers like `user_id` and `session_id`.
    - **Why it's used:** When your tools perform actions (like generating an image or interacting with an external API), you can log these actions alongside the relevant user and session IDs. This is invaluable for debugging, auditing, and understanding user behavior. Our `generate_image` tool uses this to create unique filenames in Azure Blob Storage.
4. **Security and Authorization:**
    - **What it is:** Sensitive information, such as authentication access tokens (`auth_access_token` in `UserInfo`), can be passed securely through the context.
    - **Why it's used:** Tools that interact with protected resources (e.g., a corporate database, a payment gateway) can use these tokens to authenticate their calls, ensuring that only authorized actions are performed. The agent itself doesn't directly handle these credentials in its prompt, enhancing security.
5. **Reusability of Tools:**
    - **What it is:** Tools become self-contained units that expect context to be provided.
    - **Why it's used:** A tool doesn't need to know the specific environment it's running in. It simply expects a `RunContextWrapper` with the necessary information, making it highly reusable across different agents or even different applications within the same framework.

---

### How is `RunContextWrapper` Passed and Used?

The process of passing and utilizing the `RunContextWrapper` involves two main steps:

### 1. Instantiating and Passing Your Custom Context to the `Runner`

When you initiate an agent's execution, you typically do so through a `Runner` class (or similar orchestrator in your framework). This is where you create an instance of your custom context object (`UserInfo` in our case) and pass it to the `run` method.

```python
# Assuming you have your agent defined as 'image_specialist_agent'
# and the Runner class available from your agents framework

from agents import Runner # Assuming Runner is imported from 'agents'

# Create an instance of your custom context
my_user_info = UserInfo(
    email="user@example.com",
    auth_access_token="some_token_here",
    entra_id_user_id="entra-12345",
    user_id="user-abc-123",
    session_id="sess-xyz-456"
)

async def run_agent_example(user_query: str):
    print(f"User query: {user_query}")
    # The Runner's run method takes your custom context object
    result = await Runner.run(
        image_specialist_agent,
        input=user_query,
        context=my_user_info # <-- Passing the UserInfo instance here
    )
    print(f"Agent response: {result.final_output}")

# Example usage (in an async environment)
# import asyncio
# asyncio.run(run_agent_example("Can you draw a futuristic cityscape?"))
```

When `Runner.run()` is called, the framework takes your `my_user_info` object and automatically wraps it in a `RunContextWrapper`.

### 2. Accessing the Context within Your Tool Functions

Once the context is passed to the `Runner`, the agent framework ensures that any `@function_tool` decorated functions declared by your agent receive a `RunContextWrapper` object as their first parameter.

Your tool can then easily access the custom context object (your `UserInfo` instance) through the `wrapper.context` attribute:

```python
# Inside your generate_image tool function
# (from previous blog, slightly re-simplified for focus on context usage)

from agents import function_tool, RunContextWrapper
# from my_main_app_file import UserInfo, azure_blob_utils, dalle_client, DALLE_MODEL

@function_tool
def generate_image(wrapper: RunContextWrapper[UserInfo], prompt: str, style: str = "realistic", size: str = "1024x1024") -> str:
    # Access user_id and session_id from the context wrapper
    user_id = wrapper.context.user_id
    session_id = wrapper.context.session_id

    print(f"Tool called for user: {user_id}, session: {session_id}")
    # ... DALLÂ·E image generation logic ...
    openai_image_url = "http://example.com/temp_image.png" # Simplified for this snippet

    # ... image download logic ...
    temp_filepath = "/tmp/image.png" # Simplified path
    # Simulate writing to temp_filepath
    with open(temp_filepath, "w") as f:
        f.write("dummy image data")

    try:
        # Pass user_id and session_id to the upload utility
        blob_url = azure_blob_utils.upload_file(
            file=FileStorage(stream=open(temp_filepath, "rb"), filename="my_image.png", content_type="image/png"),
            user_id=user_id, # <--- Used here
            session_id=session_id, # <--- Used here
            folder="etexchat"
        )
    finally:
        os.unlink(temp_filepath)

    return json.dumps({
        "tool_type": "image_generator",
        "agent_responsible": "Etex Mate Image Generator Agent",
        "original_question": prompt,
        "image_url": blob_url,
        "size": size,
        "style": style
    })
```

As you can see, `wrapper.context.user_id` and `wrapper.context.session_id` are seamlessly extracted and used to ensure the image is stored in a structured, user-specific path within Azure Blob Storage. This demonstrates the power of context injection: the tool doesn't need to know *how* `user_id` was obtained; it simply trusts that the `wrapper` will provide it.

---

### Conclusion: The Glue for Intelligent Interactions

The `RunContextWrapper` (and the custom context objects it contains) is far more than just a minor detail in AI agent development. It is the fundamental mechanism for providing the dynamic, session-specific, and user-specific information that agents and their tools need to operate intelligently, securely, and effectively. By strategically defining and passing context, you enable your AI agents to build complex, personalized, and traceable workflows that truly adapt to the user's needs.