# Context Wrapper: Injecting User-Specific Data into Agent Tools

We've built agents that can use tools to fetch real-time information. But there's a critical limitation in our current implementation: our tools use hardcoded API keys and global configuration. This works for single-user demos, but what about production systems serving thousands of users, each with their own credentials, preferences, and permissions?

Today, we're solving this with **Context Wrappers**—a powerful pattern that lets you inject user-specific data into your agent tools without cluttering your function signatures or maintaining global state.

## The Problem: Hardcoded Credentials

Let's look at our weather tool from previous blogs:

```python
api_key = "PASTE YOUR API KEY HERE"  # ← Hardcoded!

@function_tool
def get_weather(city_name: str) -> dict:
    base_url = "https://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city_name,
        "appid": api_key,  # ← Uses global variable
        "units": "metric"
    }
    # ... rest of implementation

```

### What's Wrong With This?

**1. No Per-User Credentials**
Every user shares the same API key. You can't:

- Use user-specific API keys
- Implement per-user rate limiting
- Track API usage per user
- Support different subscription tiers

**2. No User Context**
Your tools can't access:

- User preferences (units, language)
- User permissions (what data can they access?)
- User profile information
- Session-specific data

**3. Testing Nightmare**
How do you test with different users? Change the global variable every time? That's fragile and error-prone.

**4. Security Issues**
Hardcoded credentials in code are a security risk. They end up in version control, logs, and error messages.

The solution? **Context Wrappers**.

## Defining User Context with Dataclasses

First, we define what user-specific information we need:

```python
from dataclasses import dataclass

@dataclass
class UserInfo:
    user_name: str
    user_api_key: str

```

### Why Use a Dataclass?

The `@dataclass` decorator creates a class with automatic initialization, representation, and comparison. It's perfect for holding configuration:

**What We Get:**

```python
user = UserInfo(user_name="Alice", user_api_key="abc123")
print(user.user_name)  # "Alice"
print(user)  # UserInfo(user_name='Alice', user_api_key='abc123')

```

**Without the Decorator:**

```python
class UserInfo:
    def __init__(self, user_name: str, user_api_key: str):
        self.user_name = user_name
        self.user_api_key = user_api_key

    def __repr__(self):
        return f"UserInfo(user_name={self.user_name}, user_api_key={self.user_api_key})"

```

Dataclasses save boilerplate while providing type hints and clean structure.

### Designing Your Context

Think about what each tool needs:

```python
@dataclass
class UserInfo:
    # Authentication
    user_name: str
    user_api_key: str

    # Could also include:
    # user_id: str
    # email: str
    # subscription_tier: str
    # preferences: Dict[str, Any]
    # permissions: List[str]
    # rate_limit_remaining: int

```

Keep it focused—only include data that tools actually need. Context flows through every tool call, so unnecessary data adds overhead.

## Creating Context-Aware Tools

Now let's rebuild our weather tool to use context:

```python
import requests
from agents import function_tool, RunContextWrapper

@function_tool
def get_weather(wrapper: RunContextWrapper[UserInfo], city_name: str) -> dict:
    """
    Fetch current weather information for a given city using OpenWeatherMap API.

    Args:
        city_name (str): Name of the city (e.g., "London").

    Returns:
        dict: Weather information including temperature, description, humidity, etc.
    """
    api_key = wrapper.context.user_api_key
    base_url = "https://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city_name,
        "appid": api_key,
        "units": "metric"
    }

    try:
        response = requests.get(base_url, params=params)
        response.raise_for_status()
        data = response.json()

        weather = {
            "city": data["name"],
            "temperature": data["main"]["temp"],
            "description": data["weather"][0]["description"],
            "humidity": data["main"]["humidity"],
            "wind_speed": data["wind"]["speed"]
        }
        return weather

    except requests.exceptions.RequestException as e:
        print(f"Network error: {e}")
        return {}
    except KeyError:
        print(f"Could not find weather for '{city_name}'. Check the city name.")
        return {}

```

### Breaking Down the Changes

**1. The Context Wrapper Parameter**

```python
def get_weather(wrapper: RunContextWrapper[UserInfo], city_name: str) -> dict:

```

The first parameter is now `wrapper: RunContextWrapper[UserInfo]`. This is a special parameter that:

- **Is not visible to the agent**: The language model doesn't see this parameter in the tool schema
- **Is automatically injected**: The framework provides it at runtime
- **Provides access to context**: Through `wrapper.context`

The type parameter `[UserInfo]` tells Python (and your IDE) what type of context to expect, enabling autocomplete and type checking.

**2. Accessing Context Data**

```python
api_key = wrapper.context.user_api_key

```

Instead of using a global `api_key` variable, we access the user's specific API key through the context wrapper. Every time this tool runs, it uses the API key of the current user making the request.

**3. No Changes to Tool Logic**

Everything after accessing the API key remains the same. The core logic doesn't need to know about contexts or wrappers—it just works with the data provided.

**4. Updated Docstring**

```python
"""
Fetch current weather information for a given city using OpenWeatherMap API.

Args:
    city_name (str): Name of the city (e.g., "London").

Returns:
    dict: Weather information including temperature, description, humidity, etc.
"""

```

Notice: the docstring doesn't mention `wrapper`. That's intentional! Since the agent can't see or control this parameter, we don't document it in the tool description. We only document parameters the agent needs to provide.

## Creating a Context-Aware Agent

Now we define our agent with context support:

```python
custom_agent = Agent[UserInfo](
    name="My Custom Agent",
    instructions="You are an AI agent",
    model=OpenAIChatCompletionsModel(model=model_name, openai_client=agent_client),
    tools=[get_weather]
)

```

### The Key Difference

```python
Agent[UserInfo](...)

```

The `[UserInfo]` type parameter tells the agent what type of context it works with. This:

- Enables type checking
- Documents the agent's context requirements
- Ensures context and tools are compatible

Compare to our previous agent:

```python
# Before: No context
Agent(...)

# After: With context
Agent[UserInfo](...)

```

## Running the Agent with Context

Finally, we provide user-specific context when running the agent:

```python
my_user_info = {
    "user_name": "Sai Ram Penjarla",
    "user_api_key": "My API KEY",
}

result = await Runner.run(
    custom_agent,
    input="hey hi. What's the weather in Tokyo?",
    context=my_user_info
)
display(Markdown(result.final_output))

```

### The Context Parameter

```python
context=my_user_info

```

This is where the magic happens. When you provide context to `Runner.run()`:

1. **Context flows through execution**: The runner stores this context
2. **Tools receive context**: Every tool call gets access to this context through the wrapper
3. **Context persists**: Throughout the entire agent execution
4. **Tools stay isolated**: Each tool gets the same context but can't modify the shared state

### Context as a Dictionary

Notice we passed context as a dictionary:

```python
my_user_info = {
    "user_name": "Sai Ram Penjarla",
    "user_api_key": "My API KEY",
}

```

The framework automatically converts this to a `UserInfo` dataclass instance. You could also pass the dataclass directly:

```python
my_user_info = UserInfo(
    user_name="Sai Ram Penjarla",
    user_api_key="My API KEY"
)

result = await Runner.run(
    custom_agent,
    input="hey hi. What's the weather in Tokyo?",
    context=my_user_info
)

```

Both work identically.

## The Complete Execution Flow

Let's trace what happens with context:

```
┌─────────────────────────────────────────────────────────────┐
│ 1. USER REQUEST                                             │
│    - Input: "What's the weather in Tokyo?"                  │
│    - Context: {user_name: "Sai Ram", user_api_key: "..."}  │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. RUNNER INITIALIZATION                                    │
│    - Stores context in RunContext                           │
│    - Initializes agent with context type                    │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. AGENT REASONING                                          │
│    - Analyzes: "User wants Tokyo weather"                   │
│    - Selects tool: get_weather                              │
│    - Prepares call: get_weather(city_name="Tokyo")          │
│    - (Context wrapper parameter is invisible to agent)      │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. FRAMEWORK TOOL INVOCATION                                │
│    - Creates wrapper with stored context                    │
│    - Calls: get_weather(wrapper, "Tokyo")                   │
│    - Tool receives both wrapper and city_name               │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. TOOL EXECUTION                                           │
│    - Extracts: api_key = wrapper.context.user_api_key      │
│    - Uses user's specific API key                           │
│    - Makes API call to OpenWeatherMap                       │
│    - Returns weather data                                   │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. RESPONSE GENERATION                                      │
│    - Agent receives tool output                             │
│    - Generates natural language response                    │
│    - Returns to user                                        │
└─────────────────────────────────────────────────────────────┘

```

The key insight: **context flows automatically without the agent knowing about it**.

## Real-World Context Use Cases

### Use Case 1: Multi-Tenant SaaS

```python
@dataclass
class TenantContext:
    tenant_id: str
    tenant_name: str
    database_url: str
    api_quota_remaining: int

@function_tool
def query_database(wrapper: RunContextWrapper[TenantContext], query: str) -> list:
    # Each tenant queries their own database
    db_url = wrapper.context.database_url

    # Check quota
    if wrapper.context.api_quota_remaining <= 0:
        return {"error": "API quota exceeded"}

    # Execute query on tenant-specific database
    return execute_query(db_url, query)

```

### Use Case 2: User Preferences

```python
@dataclass
class UserPreferences:
    user_id: str
    temperature_unit: str  # "celsius" or "fahrenheit"
    language: str
    timezone: str

@function_tool
def get_weather(wrapper: RunContextWrapper[UserPreferences], city: str) -> dict:
    # Use user's preferred temperature unit
    units = "metric" if wrapper.context.temperature_unit == "celsius" else "imperial"

    # Make API call with user preferences
    weather = fetch_weather(city, units=units)

    # Format in user's language
    return translate_weather(weather, wrapper.context.language)

```

### Use Case 3: Permission Checking

```python
@dataclass
class UserContext:
    user_id: str
    permissions: List[str]
    role: str

@function_tool
def delete_record(wrapper: RunContextWrapper[UserContext], record_id: str) -> dict:
    # Check if user has permission
    if "delete" not in wrapper.context.permissions:
        return {"error": "Permission denied"}

    # Admins can delete any record, users only their own
    if wrapper.context.role != "admin":
        if not is_owned_by_user(record_id, wrapper.context.user_id):
            return {"error": "Cannot delete other users' records"}

    return delete_record_from_db(record_id)

```

### Use Case 4: Session State

```python
@dataclass
class SessionContext:
    session_id: str
    cart_items: List[str]
    user_location: str
    session_start_time: datetime

@function_tool
def add_to_cart(wrapper: RunContextWrapper[SessionContext], product_id: str) -> dict:
    # Access user's cart from context
    cart = wrapper.context.cart_items

    # Check product availability in user's location
    available = check_availability(product_id, wrapper.context.user_location)

    if not available:
        return {"error": f"Product not available in {wrapper.context.user_location}"}

    # Update cart
    cart.append(product_id)
    return {"success": True, "cart_size": len(cart)}

```

## Advanced Context Patterns

### Pattern 1: Nested Context

```python
@dataclass
class APICredentials:
    weather_api_key: str
    maps_api_key: str
    db_password: str

@dataclass
class UserInfo:
    user_name: str
    user_id: str
    credentials: APICredentials
    preferences: Dict[str, Any]

@function_tool
def get_weather(wrapper: RunContextWrapper[UserInfo], city: str) -> dict:
    api_key = wrapper.context.credentials.weather_api_key
    # Use nested context

```

### Pattern 2: Context with Methods

```python
@dataclass
class SmartContext:
    user_id: str
    api_keys: Dict[str, str]

    def get_api_key(self, service: str) -> str:
        return self.api_keys.get(service, "")

    def has_permission(self, permission: str) -> bool:
        # Complex permission logic
        return True

@function_tool
def use_service(wrapper: RunContextWrapper[SmartContext], service: str) -> dict:
    if not wrapper.context.has_permission("use_external_api"):
        return {"error": "No permission"}

    api_key = wrapper.context.get_api_key(service)
    # Use the key

```

### Pattern 3: Dynamic Context Updates

While context is generally immutable during a single run, you can return updated context for the next interaction:

```python
@dataclass
class StatefulContext:
    api_calls_made: int
    last_query_time: datetime

# In your application layer:
result = await Runner.run(agent, input=query, context=ctx)

# Update context for next call
ctx.api_calls_made += 1
ctx.last_query_time = datetime.now()

next_result = await Runner.run(agent, input=next_query, context=ctx)

```

## Context vs. Memory

It's important to distinguish context from memory:

### Memory (Conversation History)

- **What**: Previous messages and interactions
- **Scope**: Shared across the conversation
- **Visibility**: The agent sees and reasons about memory
- **Purpose**: Maintain conversational context

### Context (Runtime Data)

- **What**: User-specific configuration and credentials
- **Scope**: Per user or session
- **Visibility**: Invisible to the agent, only tools access it
- **Purpose**: Provide tools with necessary data

**Example:**

```python
# Memory: The agent remembers what was discussed
messages = [
    {"role": "user", "content": "What's the weather in Tokyo?"},
    {"role": "assistant", "content": "It's 25°C and rainy"},
    {"role": "user", "content": "What about London?"}
]

# Context: Tools use user-specific data
context = UserInfo(
    user_name="Alice",
    user_api_key="abc123"
)

# The agent uses memory to understand "What about London?" refers to weather
# Tools use context to authenticate API calls with Alice's key

```

## Benefits of Context Wrappers

### 1. Clean Separation of Concerns

- **Tools**: Focus on their core functionality
- **Agent**: Reasons about high-level tasks
- **Framework**: Manages context injection

### 2. Type Safety

```python
# Your IDE knows what's available:
wrapper.context.user_api_key  # ✅ Autocompletes
wrapper.context.invalid_field  # ❌ Type error

```

### 3. Testability

Easy to test tools with different contexts:

```python
test_context = UserInfo(
    user_name="Test User",
    user_api_key="test_key_123"
)

# Test with specific context
result = await Runner.run(agent, input="test query", context=test_context)

```

### 4. Security

- Credentials never hardcoded
- Per-user isolation
- Easy to implement permission checks
- No global state to leak

### 5. Flexibility

- Different users → different contexts
- Easy to add new context fields
- Tools opt-in to using context
- Context can vary by environment (dev/staging/prod)

## Common Pitfalls and Solutions

### Pitfall 1: Forgetting the Wrapper Parameter

❌ **Wrong:**

```python
@function_tool
def get_weather(city_name: str) -> dict:
    api_key = context.user_api_key  # Where does 'context' come from?

```

✅ **Right:**

```python
@function_tool
def get_weather(wrapper: RunContextWrapper[UserInfo], city_name: str) -> dict:
    api_key = wrapper.context.user_api_key

```

### Pitfall 2: Documenting the Wrapper

❌ **Wrong:**

```python
"""
Args:
    wrapper: The context wrapper (DO NOT document this)
    city_name: The city name
"""

```

✅ **Right:**

```python
"""
Args:
    city_name: The city name
"""

```

The agent can't see or control the wrapper parameter, so don't document it.

### Pitfall 3: Modifying Context

❌ **Wrong:**

```python
@function_tool
def use_api(wrapper: RunContextWrapper[UserInfo], query: str) -> dict:
    wrapper.context.api_calls_made += 1  # Modifying context directly

```

✅ **Right:**

```python
# Context should be treated as read-only within tools
# Update it in your application layer between runs

```

### Pitfall 4: Wrong Parameter Order

❌ **Wrong:**

```python
@function_tool
def get_weather(city_name: str, wrapper: RunContextWrapper[UserInfo]) -> dict:
    # Wrapper must be the first parameter!

```

✅ **Right:**

```python
@function_tool
def get_weather(wrapper: RunContextWrapper[UserInfo], city_name: str) -> dict:
    # Wrapper is always first

```

## What We've Accomplished

Today we've mastered a critical production pattern:

- ✅ Defined user context with dataclasses
- ✅ Created context-aware tools
- ✅ Understood the RunContextWrapper mechanism
- ✅ Saw how context flows through execution
- ✅ Explored real-world use cases
- ✅ Learned advanced context patterns
- ✅ Distinguished context from memory
- ✅ Avoided common pitfalls

Context wrappers transform your agent from a demo into a production-ready system that can serve multiple users securely and efficiently.

## What's Next

We now have agents that can remember conversations and use tools with user-specific context. But what happens when tasks become too complex for a single agent?

In the next blog, we'll explore **building multiple specialized agents**—creating agent teams where each member has specific expertise and responsibilities.

After that, we'll learn how to orchestrate these agents with **handoffs**, allowing them to collaborate seamlessly on complex tasks.

---

*Next: Building Multiple Agents—creating specialized agent teams for complex workflows.*