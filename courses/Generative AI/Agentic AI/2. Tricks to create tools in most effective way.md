# 2. Tricks to create tools in most effective way

When designing tools for your AI agents, there are several best practices that significantly improve the agent's ability to understand, use, and interpret the tool's output accurately.

### 1. Clear Docstrings: The LLM's Manual

The docstring of your function isn't just for human developers; it's the primary way the LLM understands what your tool does, when to use it, and what parameters it needs.

- **Be Descriptive:** Clearly explain the tool's purpose.
- **Parameter Explanation:** Detail each parameter, its type, and what it represents.
- **Return Value Description:** Explain what the tool returns.

```python
@function_tool
def generate_image(wrapper: RunContextWrapper[UserInfo], prompt: str, style: str = "realistic", size: str = "1024x1024") -> str:
    """Generate an image using DALL·E, save to Azure Blob Storage, and return a JSON string with the blob URL.

    This tool takes a text description (prompt) and generates an image, then stores it.

    Args:
        wrapper (RunContextWrapper[UserInfo]): Provides context about the current user and session.
                                               Used for organizing stored files.
        prompt (str): The detailed text description of the image to generate.
        style (str, optional): The artistic style for the image (e.g., "realistic", "cartoon", "abstract").
                               Defaults to "realistic".
        size (str, optional): The dimensions of the image (e.g., "1024x1024", "1792x1024", "1024x1792").
                              Defaults to "1024x1024".

    Returns:
        str: A JSON string containing details of the generated image, including:
             - "tool_type": Identifier for the tool type ("image_generator").
             - "agent_responsible": The name of the agent calling this tool (e.g., "Image Creation Agent").
             - "original_question": The initial question or intent that led to this tool call.
             - "image_url": The public URL where the generated image is stored in Azure Blob Storage.
             - "size": The size of the generated image.
    """
    # ... (function body) ...
```

### 2. Accurate Type Hints: Guiding the LLM's Parsing

Python type hints (e.g., `prompt: str`, `-> str`) are crucial. They provide explicit information to the agent framework and LLM about the expected data types for inputs and outputs. This helps the LLM correctly parse arguments when calling your tool and interpret the results.

- **For Parameters:** Ensure all parameters have clear type hints.
- **For Return Value:** Specify the return type (e.g., `> str` for our JSON string).

### 3. Structured Return Value (JSON String): Higher Accuracy and Context

While a tool *could* return a plain string, returning a JSON string is a best practice for several reasons:

- **Clarity for LLM:** JSON provides a clear, machine-readable structure that the LLM can reliably parse and understand.
- **Richer Information:** You can include multiple pieces of information in a single, well-organized object.
- **Higher Accuracy:** Explicit structure reduces ambiguity, leading to more accurate processing by the agent.

Crucially, the JSON output should include metadata vital for the agent's ongoing reasoning:

- **`"agent_responsible"`:** In a multi-agent system, knowing which agent called a tool is essential for an orchestrator agent or for debugging. This parameter allows the system to trace responsibility.
- **`"original_question"` (or `tool_text` / `prompt`):** If an agent chains together many tool calls (e.g., a "deep research agent" calling 25-30 tools), it can sometimes lose sight of the initial user query. Including the original question in the tool's output helps the agent stay grounded and aware of its primary objective.
- **Other Relevant Parameters:** Include any other data from the tool's execution that might be useful for the agent's subsequent steps or for informing the user.

```json
{
    "tool_type": "image_generator",
    "agent_responsible": "Etex Mate Image Generator Agent",
    "original_question": "Can you generate a picture of a cat playing a tiny violin in a cozy library?",
    "image_url": "https://youraccount.blob.core.windows.net/ai-generated-content/user123/session456/generated_image_user123_session456_abcdef12345.png",
    "size": "1024x1024",
    "style": "realistic"
}
```

---

### Putting It All Together: The Complete `generate_image` Tool

Here's the combined, cleaned-up `generate_image` function, incorporating all the discussed elements for a robust AI agent tool.

```python
import os
import requests
import tempfile
import uuid
import json
from openai import AzureOpenAI
from werkzeug.datastructures import FileStorage

# Assuming these are part of your agent framework setup
from agents import function_tool, RunContextWrapper

# --- Configuration for DALL·E (replace with your actual environment variables) ---
DALLE_API_VERSION = os.environ.get('AZURE_DALLE_API_VERSION', '2024-02-15-preview')
DALLE_ENDPOINT = os.environ.get('AZURE_DALLE_ENDPOINT', 'YOUR_DALLE_ENDPOINT')
DALLE_API_KEY = os.environ.get('AZURE_DALLE_API_KEY', 'YOUR_DALLE_API_KEY')
DALLE_MODEL = os.environ.get('DALLE_MODEL', 'dall-e-3')

# --- Simplified AzureBlobUtilities for demonstration ---
# In a real application, you'd initialize BlobServiceClient with proper credentials
# and container_name (e.g., from environment variables)
from azure.storage.blob import BlobServiceClient, ContentSettings # pip install azure-storage-blob

class AzureBlobUtilities:
    def __init__(self, connection_string: str, container_name: str):
        self.blob_service_client = BlobServiceClient.from_connection_string(connection_string)
        self.container_client = self.blob_service_client.get_container_client(container_name)
        # Ensure the container exists (optional, but good for setup)
        try:
            self.container_client.create_container()
        except Exception:
            pass # Container likely already exists

    def upload_file(self, file: FileStorage, user_id: str, session_id: str, folder: str) -> str:
        """
        Uploads a file to Azure Blob Storage under user_id/session_id/ in a specified folder.
        Returns the public URL of the uploaded file.
        """
        # Construct the blob path: folder/user_id/session_id/filename
        blob_path = f"{folder}/{user_id}/{session_id}/{file.filename}"
        blob_client = self.container_client.get_blob_client(blob_path)

        # Determine content type based on file extension
        content_type = "application/octet-stream"
        if file.filename.lower().endswith(".pdf"):
            content_type = "application/pdf"
        elif file.filename.lower().endswith((".jpg", ".jpeg")):
            content_type = "image/jpeg"
        elif file.filename.lower().endswith(".png"):
            content_type = "image/png"

        try:
            blob_client.upload_blob(
                file.stream,  # Use file.stream for FileStorage object
                overwrite=True,
                content_settings=ContentSettings(content_type=content_type),
            )
            return blob_client.url
        except Exception as e:
            print(f"Error uploading file {file.filename}: {str(e)}")
            return None

# Initialize DALL·E client and Azure Blob utility
dalle_client = AzureOpenAI(
    api_version=DALLE_API_VERSION,
    azure_endpoint=DALLE_ENDPOINT,
    api_key=DALLE_API_KEY
)

AZURE_STORAGE_CONNECTION_STRING = os.environ.get('AZURE_STORAGE_CONNECTION_STRING', 'DefaultEndpointsProtocol=...')
AZURE_BLOB_CONTAINER_NAME = os.environ.get('AZURE_BLOB_CONTAINER_NAME', 'ai-agent-images')
azure_blob_utils = AzureBlobUtilities(AZURE_STORAGE_CONNECTION_STRING, AZURE_BLOB_CONTAINER_NAME)

# Placeholder for UserInfo, assuming it's a dataclass or similar
class UserInfo:
    def __init__(self, user_id: str, session_id: str):
        self.user_id = user_id
        self.session_id = session_id

@function_tool
def generate_image(wrapper: RunContextWrapper[UserInfo], prompt: str, style: str = "realistic", size: str = "1024x1024") -> str:
    """Generate an image using DALL·E, save to Azure Blob Storage, and return a JSON string with the blob URL.

    This tool takes a text description (prompt) and generates an image, then stores it.

    Args:
        wrapper (RunContextWrapper[UserInfo]): Provides context about the current user and session.
                                               Used for organizing stored files.
        prompt (str): The detailed text description of the image to generate.
        style (str, optional): The artistic style for the image (e.g., "realistic", "cartoon", "abstract").
                               Defaults to "realistic".
        size (str, optional): The dimensions of the image (e.g., "1024x1024", "1792x1024", "1024x1792").
                              Defaults to "1024x1024".

    Returns:
        str: A JSON string containing details of the generated image, including:
             - "tool_type": Identifier for the tool type ("image_generator").
             - "agent_responsible": The name of the agent calling this tool (e.g., "Image Creation Agent").
             - "original_question": The initial question or intent that led to this tool call.
             - "image_url": The public URL where the generated image is stored in Azure Blob Storage.
             - "size": The size of the generated image.
             - "style": The style of the generated image.
    """
    print(f"Generating image with prompt: {prompt}, style: {style}, size: {size}")
		user_id: str = wrapper.context.user_id
		
    valid_sizes = ["1024x1024", "1792x1024", "1024x1792"]
    if size not in valid_sizes:
        raise ValueError(f"Size must be one of {valid_sizes}. Got: {size}")

    # Step 1: Generate image from OpenAI (DALL·E)
    response = dalle_client.images.generate(
        model=DALLE_MODEL,
        prompt=prompt,
        size=size,
        n=1,
        quality="hd"
    )
    openai_image_url = response.data[0].url
    print(f"Image generated. OpenAI URL: {openai_image_url}")

    # Step 2: Download the image
    download_response = requests.get(openai_image_url)
    if download_response.status_code != 200:
        raise Exception(f"Failed to download image from OpenAI: {download_response.status_code}")

    # Step 3: Save to a temporary file
    unique_id = uuid.uuid4().hex
    # Use user_id and session_id from the context for organizing files in blob storage
    image_filename = f"generated_image_{wrapper.context.user_id}_{wrapper.context.session_id}_{unique_id}.png"
    temp_filepath = os.path.join(tempfile.gettempdir(), image_filename)

    try:
        with open(temp_filepath, "wb") as tmp_file:
            tmp_file.write(download_response.content)

        # Step 4: Upload to blob
        with open(temp_filepath, "rb") as f:
            file_obj = FileStorage(stream=f, filename=image_filename, content_type="image/png")
            blob_url = azure_blob_utils.upload_file(
                file=file_obj,
                user_id=wrapper.context.user_id,
                session_id=wrapper.context.session_id,
                folder="etexchat" # A logical folder within your blob container
            )
        print(f"Image uploaded to blob: {blob_url}")
    finally:
        os.unlink(temp_filepath) # Always clean up the temporary file

    # Step 5: Return structured result with blob URL and other important info
    return json.dumps({
        "tool_type": "image_generator",
        "agent_responsible": "Etex Mate Image Generator Agent", # Example agent name
        "original_question": prompt, # The original prompt serves as the original question
        "image_url": blob_url,
        "size": size,
        "style": style
    })
```

---

### Conclusion: Empowering Your Agents with Custom Skills

You've now seen the full cycle of creating a custom tool for an AI agent: from defining its purpose and inputs to integrating external services and structuring its output for optimal agent understanding. By following these best practices – clear docstrings, accurate type hints, and rich JSON returns – you equip your AI agents with highly reliable and context-aware capabilities. This allows them to autonomously perform complex actions and deliver more comprehensive results.

This image generation tool is just one example. The possibilities are endless when you empower your AI agents with custom skills. In our next blog, we'll delve into how an AI agent actually orchestrates these tools – how it decides which tool to call, processes the outputs, and manages complex multi-step workflows. Stay tuned!