# Building Tools for AI Agents: From Functions to Actions

We've built an agent that can converse and remember. But so far, our agent lives in a bubble—it can only talk about what it knows from training. It can't check the current weather, query a database, or fetch real-time information.

Today, we're breaking down that wall. We're going to build **tools**—the mechanism that lets agents interact with the real world. By the end of this blog, your agent will be able to take actions, not just respond.

## The Power of Tools

Tools transform agents from conversational systems into action-oriented systems. A tool is simply a function that an agent can call to:

- Fetch real-time data (weather, stock prices, news)
- Query databases or APIs
- Perform calculations or data transformations
- Control external systems (send emails, create calendar events)
- Execute code or run simulations
- Access files or documents

The key insight: **agents can decide when and how to use tools based on the user's needs.** You don't explicitly call tools—the agent reasons about when they're needed.

## Step 1: Simulating Tools Without Real APIs

Before we connect to real external APIs, let's start with a simulation. This is a crucial development practice—you can build and test your agent's tool-using behavior without depending on external services, API keys, or rate limits.

### Creating a Dummy Weather Function

```python
api_key = "Sample_API_KEY"

def get_weather(city_name) -> dict:
    if api_key == "Sample_API_KEY":
        weather = {
            "city": city_name,
            "temperature": 25,
            "description": "Light rain",
            "humidity": 70,
            "wind_speed": 8
        }
        return weather

```

This function simulates a weather API call. Notice the conditional check—if we're using a dummy API key, return static data. This pattern lets you switch between simulation and real API calls with a single configuration change.

### Testing the Simulation

```python
weather_info = get_weather("Tokyo")

if weather_info:
    print(f"🌍 Weather in {weather_info['city']}:")
    print(f"🌡 Temperature: {weather_info['temperature']}°C")
    print(f"☁️ Description: {weather_info['description'].title()}")
    print(f"💧 Humidity: {weather_info['humidity']}%")
    print(f"🌬 Wind Speed: {weather_info['wind_speed']} m/s")

```

**Output:**

```
🌍 Weather in Tokyo:
🌡 Temperature: 25°C
☁️ Description: Light Rain
💧 Humidity: 70%
🌬 Wind Speed: 8 m/s

```

Perfect! We have a working function that returns structured weather data. The function works exactly like a real API would—it takes a city name and returns detailed weather information.

### Why Start with Simulation?

Starting with dummy data offers several advantages:

1. **No External Dependencies**: Develop without internet, API keys, or service availability
2. **Predictable Testing**: Same input always gives same output—great for debugging
3. **No Rate Limits**: Test repeatedly without hitting API quotas
4. **Cost Control**: Many APIs charge per call—simulation is free
5. **Faster Iteration**: No network latency, instant responses
6. **Error Handling**: Test edge cases without triggering real errors

This is especially valuable when building complex multi-tool agents where you need to test tool interaction patterns before dealing with real API complexity.

## Step 2: Connecting to Real APIs

Once your simulation works, you can graduate to real API calls. Let's connect to OpenWeatherMap's actual weather API.

### The Real Weather Function

```python
import requests

api_key = "PASTE YOUR API KEY HERE"

def get_weather(city_name: str) -> dict:
    base_url = "https://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city_name,
        "appid": api_key,
        "units": "metric"  # use "imperial" for Fahrenheit
    }

    response = requests.get(base_url, params=params)
    response.raise_for_status()  # raise error for non-200 status
    data = response.json()

    return {
        "city": data["name"],
        "temperature": data["main"]["temp"],
        "description": data["weather"][0]["description"],
        "humidity": data["main"]["humidity"],
        "wind_speed": data["wind"]["speed"]
    }

```

### Breaking Down the Real API Call

**1. API Configuration**

```python
base_url = "https://api.openweathermap.org/data/2.5/weather"
params = {
    "q": city_name,
    "appid": api_key,
    "units": "metric"
}

```

We construct the request with:

- `q`: The city to query
- `appid`: Your authentication key
- `units`: Metric (Celsius) or imperial (Fahrenheit)

**2. Making the Request**

```python
response = requests.get(base_url, params=params)
response.raise_for_status()

```

The `requests.get()` call sends an HTTP GET request to the API. The `raise_for_status()` method will throw an exception if the API returns an error (404, 500, etc.), which is important for error handling.

**3. Parsing the Response**

```python
data = response.json()

```

The API returns JSON data. We parse it into a Python dictionary for easy access.

**4. Extracting Relevant Data**

```python
return {
    "city": data["name"],
    "temperature": data["main"]["temp"],
    "description": data["weather"][0]["description"],
    "humidity": data["main"]["humidity"],
    "wind_speed": data["wind"]["speed"]
}

```

Real API responses are often verbose and nested. We extract only what we need and return it in a clean, consistent format—the same format our simulation uses.

**This consistency is crucial**: By matching the simulation's structure, you can swap between simulated and real API calls without changing any other code.

### Obtaining an API Key

To use OpenWeatherMap's API:

1. Visit [openweathermap.org](https://openweathermap.org/api)
2. Sign up for a free account
3. Navigate to API keys section
4. Generate a new key
5. Replace `"PASTE YOUR API KEY HERE"` with your actual key

Most weather APIs offer free tiers with generous limits—plenty for development and testing.

## Step 3: Turning Functions into Agent Tools

Now comes the magic: converting our function into something an agent can use. We need to tell the agent framework that this function is available as a tool.

### The @function_tool Decorator

```python
from agents import function_tool

@function_tool
def get_weather(city_name: str) -> dict:
    """
    Get current weather information for a specific city.

    Args:
        city_name: The name of the city to get weather for

    Returns:
        Dictionary containing temperature, description, humidity, and wind speed
    """
    base_url = "https://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city_name,
        "appid": api_key,
        "units": "metric"
    }

    response = requests.get(base_url, params=params)
    response.raise_for_status()
    data = response.json()

    return {
        "city": data["name"],
        "temperature": data["main"]["temp"],
        "description": data["weather"][0]["description"],
        "humidity": data["main"]["humidity"],
        "wind_speed": data["wind"]["speed"]
    }

```

### What Does @function_tool Do?

The `@function_tool` decorator is a Python decorator that wraps your function and makes it agent-compatible. Here's what happens under the hood:

**1. Schema Generation**

The decorator inspects your function to create a schema—a formal description of:

- Function name: `get_weather`
- Parameters: `city_name` (string)
- Return type: `dict`
- Description: Extracted from the docstring

This schema is what the language model sees. When the agent receives a query like "What's the weather in Tokyo?", it can examine available tools and their schemas to decide if `get_weather` is appropriate.

**2. Type Validation**

The decorator enforces type hints. If you declare `city_name: str` but the agent tries to pass an integer, the decorator catches this error before calling your function.

**3. Execution Wrapper**

The decorator wraps the actual function call, handling:

- Calling the function with provided arguments
- Capturing the return value
- Formatting the result for the agent
- Catching and reporting errors

**4. Tool Registration**

The decorated function is registered in the agent framework's tool registry, making it discoverable by agents that have access to it.

### The Importance of Docstrings

Notice the detailed docstring:

```python
"""
Get current weather information for a specific city.

Args:
    city_name: The name of the city to get weather for

Returns:
    Dictionary containing temperature, description, humidity, and wind speed
"""

```

This isn't just good practice—it's **essential for agent tool use**. The language model uses this description to decide when to call the tool. Compare these scenarios:

**Poor Docstring:**

```python
"""Get weather"""

```

The agent might be unsure if this gets forecasts, historical data, or current conditions.

**Good Docstring:**

```python
"""Get current weather information for a specific city."""

```

Clear and specific—the agent knows exactly what this tool does.

**Great Docstring (what we used):**

```python
"""
Get current weather information for a specific city.

Args:
    city_name: The name of the city to get weather for

Returns:
    Dictionary containing temperature, description, humidity, and wind speed
"""

```

Detailed description of inputs and outputs—the agent can use this with confidence.

The model reads these docstrings when deciding which tool to use. Better descriptions lead to better tool selection.

## How Tools Change Agent Behavior

Let's understand what happens when an agent has access to tools:

### Without Tools

**User:** "What's the weather in Tokyo?"

**Agent:** "I don't have access to real-time weather information. My knowledge was last updated in January 2025, so I cannot provide current weather conditions for Tokyo."

The agent is limited to its training data.

### With Tools

**User:** "What's the weather in Tokyo?"

**Agent's Internal Process:**

1. Analyzes query: User wants current weather for Tokyo
2. Checks available tools: Finds `get_weather` function
3. Reads tool description: Confirms it provides current weather
4. Decides to use tool: This tool matches the user's need
5. Calls tool: `get_weather("Tokyo")`
6. Receives result: Weather data dictionary
7. Formulates response: Synthesizes natural language answer from data

**Agent:** "The current weather in Tokyo is 25°C with light rain. Humidity is at 70% and wind speed is 8 m/s."

The agent autonomously decided to use the tool and synthesized the result into a natural response.

## The Tool-Using Loop

When agents have tools, their execution changes from:

**Simple Response Loop:**

```
Input → Processing → Output

```

To a **Tool-Enabled Loop:**

```
Input → Reasoning → Tool Decision → Tool Execution → Result Integration → Output

```

This loop can repeat multiple times in a single query:

```
User: "Compare the weather in Tokyo and London"

Agent Loop:
1. Call get_weather("Tokyo")
2. Call get_weather("London")
3. Analyze both results
4. Generate comparison response

```

The agent orchestrates multiple tool calls automatically, without you writing explicit logic for it.

## Design Principles for Good Tools

As you build tools for your agents, follow these principles:

### 1. Single Responsibility

Each tool should do one thing well:

❌ Bad:

```python
def weather_and_news(city):
    # Gets weather and news - too much

```

✅ Good:

```python
def get_weather(city):
    # Only gets weather

def get_news(location):
    # Only gets news

```

### 2. Consistent Return Format

Tools should return predictable, structured data:

✅ Good:

```python
return {
    "city": "Tokyo",
    "temperature": 25,
    "description": "Light rain"
}

```

❌ Bad:

```python
return "It's 25 degrees and rainy in Tokyo"  # Unstructured string

```

### 3. Clear Error Handling

Tools should handle errors gracefully:

```python
def get_weather(city_name: str) -> dict:
    try:
        response = requests.get(base_url, params=params)
        response.raise_for_status()
        data = response.json()
        return format_weather_data(data)
    except requests.exceptions.HTTPError as e:
        return {"error": f"Failed to fetch weather: {str(e)}"}
    except KeyError as e:
        return {"error": f"Unexpected API response format: {str(e)}"}

```

This lets the agent handle failures intelligently instead of crashing.

### 4. Detailed Documentation

Always include comprehensive docstrings:

```python
@function_tool
def get_weather(city_name: str) -> dict:
    """
    Get current weather information for a specific city.

    This tool fetches real-time weather data including temperature,
    conditions, humidity, and wind speed for any major city worldwide.

    Args:
        city_name: The name of the city (e.g., "Tokyo", "London", "New York")

    Returns:
        Dictionary with keys: city, temperature (°C), description,
        humidity (%), wind_speed (m/s)

    Raises:
        Returns error dict if city not found or API fails
    """

```

### 5. Parameter Validation

Validate inputs before making expensive API calls:

```python
def get_weather(city_name: str) -> dict:
    if not city_name or not isinstance(city_name, str):
        return {"error": "City name must be a non-empty string"}

    if len(city_name) > 100:
        return {"error": "City name too long"}

    # Proceed with API call...

```

## Combining Simulation and Real APIs

Here's a production-ready pattern that combines both approaches:

```python
import os
import requests
from agents import function_tool

USE_REAL_API = os.getenv("USE_REAL_WEATHER_API", "false").lower() == "true"
WEATHER_API_KEY = os.getenv("WEATHER_API_KEY", "Sample_API_KEY")

@function_tool
def get_weather(city_name: str) -> dict:
    """Get current weather information for a specific city."""

    # Validation
    if not city_name:
        return {"error": "City name is required"}

    # Use simulation in development
    if not USE_REAL_API or WEATHER_API_KEY == "Sample_API_KEY":
        return {
            "city": city_name,
            "temperature": 25,
            "description": "Light rain",
            "humidity": 70,
            "wind_speed": 8,
            "note": "Simulated data"
        }

    # Use real API in production
    try:
        base_url = "https://api.openweathermap.org/data/2.5/weather"
        params = {
            "q": city_name,
            "appid": WEATHER_API_KEY,
            "units": "metric"
        }

        response = requests.get(base_url, params=params, timeout=5)
        response.raise_for_status()
        data = response.json()

        return {
            "city": data["name"],
            "temperature": data["main"]["temp"],
            "description": data["weather"][0]["description"],
            "humidity": data["main"]["humidity"],
            "wind_speed": data["wind"]["speed"]
        }
    except Exception as e:
        return {"error": f"Failed to fetch weather: {str(e)}"}

```

Now you can:

- Develop with simulations: `USE_REAL_API=false`
- Deploy with real APIs: `USE_REAL_API=true`
- Switch between modes with environment variables

## What We've Built

Today, we've created the foundation for action-oriented agents:

- ✅ Built a simulated tool for development
- ✅ Connected to a real external API
- ✅ Converted functions into agent tools with `@function_tool`
- ✅ Understood the tool-using execution loop
- ✅ Learned design principles for effective tools
- ✅ Implemented production-ready tool patterns

But we haven't yet connected our tool to our agent. That's intentional—we've focused on understanding tools themselves first.

## What's Next

In the next blog, we'll take a deeper look at **simulating API calls** more realistically—handling edge cases, error scenarios, rate limits, and complex data structures. This will prepare us for the variety of real-world APIs your agents will need to interact with.

After that, we'll **connect these tools to our agent** and watch it autonomously decide when and how to use them. That's when everything comes together.

---

*Next: Simulating API Calling in Tools—building robust, testable tool implementations.*