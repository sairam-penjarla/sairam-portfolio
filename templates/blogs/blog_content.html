<!-- Load marked.js for Markdown parsing -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
    const fileContent = {{ file_content|tojson }};

    function handleFileContent(content) {
        console.log("File Content:", content);
    }

    if (fileContent) {
        renderBlogDetails(fileContent);
    }
    
    function renderBlogDetails(fileContent) {
        const container = document.createElement("div");
        container.className = "blog-container";

        // Main content
        const main = document.createElement("div");
        main.className = "blog-main prompt-main-content";
        main.innerHTML = `
            <div class="blog-content message">
                ${marked.parse(fileContent)}
            </div>
        `;

        // Create TOC
        const toc = document.createElement("div");
        toc.className = "blog-toc";
        toc.innerHTML = `<ul></ul>`;

        const blogContentDiv = document.createElement("div");
        blogContentDiv.innerHTML = marked.parse(fileContent);

        // Get headings
        const headings = blogContentDiv.querySelectorAll("h1, h2");
        const tocList = toc.querySelector("ul");

        headings.forEach((h, i) => {
            const id = `heading-${i}`;
            h.id = id;

            const li = document.createElement("li");
            const a = document.createElement("a");
            a.href = `#${id}`;
            a.textContent = h.textContent;

            // Smooth scroll to center of screen
            a.addEventListener("click", function (e) {
                e.preventDefault();
                const target = document.getElementById(id);
                const targetRect = target.getBoundingClientRect();
                const targetTop = targetRect.top + window.pageYOffset;
                const windowHeight = window.innerHeight;
                const offsetTop = targetTop - windowHeight / 2 + targetRect.height / 2;

                window.scrollTo({
                    top: offsetTop,
                    behavior: "smooth",
                });
            });

            li.appendChild(a);
            tocList.appendChild(li);
        });

        // Insert headings into real blog content
        main.querySelector(".blog-content").innerHTML = blogContentDiv.innerHTML;

        // Append main & toc
        container.appendChild(main);
        container.appendChild(toc);
        document.getElementById("content").appendChild(container);

        // Scroll spy (highlight active heading) - MODIFIED TO USE .prompt-main-content
        const tocLinks = toc.querySelectorAll("a");
        if (tocLinks.length > 0) tocLinks[0].classList.add("active");

        const promptMain = document.querySelector('.prompt-main-content');
        const headingsInContent = promptMain.querySelectorAll("h1, h2");
        
        // Function to find the currently active heading within .prompt-main-content
        function updateActiveHeading() {
            if (!promptMain) return;
            const scrollContainerTop = promptMain.getBoundingClientRect().top;
            
            let activeHeading = null;
            
            for (let i = 0; i < headingsInContent.length; i++) {
                const heading = headingsInContent[i];
                const headingTop = heading.getBoundingClientRect().top - scrollContainerTop;
                
                // If the heading is within the top half of the viewport
                if (headingTop <= window.innerHeight / 2) {
                    activeHeading = heading;
                } else {
                    // Since headings are in order, we can stop once we pass the current one
                    break;
                }
            }

            // If no heading is in the top half, highlight the first one
            if (!activeHeading && headingsInContent.length > 0) {
                activeHeading = headingsInContent[0];
            }

            // Update active state
            tocLinks.forEach(link => link.classList.remove("active"));
            if (activeHeading) {
                const activeLink = toc.querySelector(`a[href="#${activeHeading.id}"]`);
                if (activeLink) {
                    activeLink.classList.add("active");
                    // Optional: scroll the TOC to keep the active link in view
                    activeLink.scrollIntoView({
                        behavior: 'smooth', 
                        block: 'nearest'
                    });
                }
            }
        }
        
        // Use scroll event for more responsive updates
        let scrollTimeout;
        promptMain.addEventListener("scroll", function () {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateActiveHeading, 10);
        });
        
        // Use IntersectionObserver for more efficient updates
        const observerOptions = {
            root: promptMain,
            rootMargin: '0px 0px -50% 0px', // Trigger when heading passes the middle of the container
            threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.id;
                    tocLinks.forEach(link => link.classList.remove('active'));
                    const activeLink = toc.querySelector(`a[href="#${id}"]`);
                    if (activeLink) {
                        activeLink.classList.add('active');
                    }
                }
            });
        }, observerOptions);

        headingsInContent.forEach(heading => {
            observer.observe(heading);
        });

        // Initial update
        updateActiveHeading();
    }
</script>
{% include 'highlightJs/highlight_js.html' %}